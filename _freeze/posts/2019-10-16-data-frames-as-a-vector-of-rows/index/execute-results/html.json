{
  "hash": "8709788e340082fceb711aee3bc31113",
  "result": {
    "markdown": "---\ntitle: Data Frames as Vectors of Rows\nauthor: Davis Vaughan\ndate: '2019-10-16'\nslug: data-frames-as-vectors-of-rows\neditor_options: \n  chunk_output_type: console\n---\n\nRecently, I have been working a lot on [{vctrs}](https://github.com/r-lib/vctrs).\nThis package is an attempt to analyze the atomic types in R, such as `integer`, `character` and `double`, alongside the recursive types of `list` and `data.frame`, to extract a set of common principles.\nFrom this analysis, a growing toolkit of functions for working with vector types has developed around two themes of *size* and *prototype*.\nvctrs is a *fun* package to work on, and even more fun to build on top of.\n\nThe goal of this post is two fold.\nFirst, I want to show off a few functions and packages that have been built using this new toolkit which contribute to why I think this package is so fun.\nSecond, I'd like to introduce a shift in the way you might normally think about data frames, *from a vector of columns to a vector of rows*.\n[Hadley is the one who recognized that viewing data frames from this angle opens up powerful new workflows that are especially useful for data analysis.]{.aside}\n\nIf you've never heard of vctrs before, there's a reason for that.\nFor the most part, it's a developer focused package, and honestly if you never knew this package existed, but still used the higher level packages that were built on top of it, then we've done our job.\nA few examples of packages that rely heavily on vctrs right now are:\n\n-   [tidyr's](https://tidyr.tidyverse.org/articles/pivot.html) `pivot_longer()` and `pivot_wider()`, along with a number of other existing functions that recently got rewritten using vctrs principles\n-   [slider](https://davisvaughan.github.io/slider/), for working with window functions (like moving averages)\n-   [rray](https://rray.r-lib.org/), an array manipulation library\n-   [tibble's](https://github.com/tidyverse/tibble) development version\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vctrs)\nlibrary(tibble, warn.conflicts = FALSE)\n```\n:::\n\n## `c()`\n\nAs you gain more experience working with R, you eventually start to learn about how certain data structures are implemented.\nA data frame, for example, is really a list where each element of the list is a single column.\nIn other words, a data frame is a vector of columns.\n\nOne way to see this is by the fact that `length()` returns the number of columns.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = 1:4, \n  y = c(\"a\", \"b\", \"a\", \"a\"), \n  z = c(\"x\", \"x\", \"y\", \"x\")\n)\n\ndf\n#> # A tibble: 4 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> 2     2 b     x    \n#> 3     3 a     y    \n#> 4     4 a     x\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(df)\n#> [1] 3\n```\n:::\n\nYou can also check that a data frame is a list by calling `is.list()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nis.list(df)\n#> [1] TRUE\n```\n:::\n\nThis underlying assumption that a data frame is a vector of columns is deeply rooted into a number of R's core functions, and is often used as a fallback when behavior is otherwise ill-defined.\nConsider, as an example, calling `c(df, df)` to \"combine\" the data frame with itself.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(df, df)\n#> $x\n#> [1] 1 2 3 4\n#> \n#> $y\n#> [1] \"a\" \"b\" \"a\" \"a\"\n#> \n#> $z\n#> [1] \"x\" \"x\" \"y\" \"x\"\n#> \n#> $x\n#> [1] 1 2 3 4\n#> \n#> $y\n#> [1] \"a\" \"b\" \"a\" \"a\"\n#> \n#> $z\n#> [1] \"x\" \"x\" \"y\" \"x\"\n```\n:::\n\nOur data frames have combined to become a list!\nIn a way, this behavior is consistent with the principle that a data frame is a list of columns.\nIt follows the invariant (read: \"unbreakable principle\") of:\n\n<center>\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(c(x, y)) == length(x) + length(y)\n```\n:::\n\n</center>\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(df) + length(df)\n#> [1] 6\n\nlength(c(df, df)) == length(df) + length(df)\n#> [1] TRUE\n```\n:::\n\nIs there any other type of output that makes sense?\nIf we think of a data frame as a vector of columns, then no, because it makes sense to end up with something of length 6 after combining.\nHowever, I'd argue that if we flip our understanding of data frames from a vector of columns to a vector of rows, then another solution comes forward which offers a different result that I have begun to find pretty attractive.\n\n## `vec_size()`\n\n[Much of this particular section is adapted from the vctrs [vignette](https://vctrs.r-lib.org/articles/type-size.html#size) on size.]{.aside}\n\nTo start the process of thinking about a \"vector of rows\", look again to `df`.\nA single \"row\" would be:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1,]\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x\n```\n:::\n\nWith that in mind, `df` would be considered a vector of 4 rows.\nIt would be nice to have a function that returned this information as a building block to work off of (as shown before, `length()` won't do).\nWe could try and use `nrow()`, which gives us what we want, but it returns `NULL` when given an individual column.\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(df)\n#> [1] 4\n\nnrow(df$x)\n#> NULL\n```\n:::\n\nWhat I'm looking for is a function that returns a value that is equivalent for the data frame itself and for any column of the data frame.\nPut another way, I'm really after the \"number of observations\".\nOne other option is to use `NROW()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nNROW(df)\n#> [1] 4\n\nNROW(df$x)\n#> [1] 4\n```\n:::\n\nThis looks good, but what happens if you give it some \"non-vector\" input?\nA practical way to think about that is something that isn't allowed to exist as a column of a data frame, for example, a function, or an `lm` object.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = mean)\n#> Error in as.data.frame.default(x[[i]], optional = TRUE): cannot coerce class '\"function\"' to a data.frame\n\nNROW(mean)\n#> [1] 1\n\nlm_cars <- lm(mpg ~ cyl, data = mtcars)\n\ndata.frame(x = lm_cars)\n#> Error in as.data.frame.default(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors): cannot coerce class '\"lm\"' to a data.frame\n\n# Treats it as a list\nNROW(lm_cars)\n#> [1] 12\n```\n:::\n\nThese objects are considered *scalar* types rather than *vector* types.\nThey are \"scalar\" in the sense that you only ever consider them one at a time.\nEven though `lm_cars` is *technically* implemented as a list, we look at it is as a single linear model object.\n\nCompare that to a double *vector* like `c(1, 2, 3)` which is made up of 3 observations.\n\nFor our purposes, it's valuable to keep scalar and vector types distinct, so it would be nice if an error was thrown for scalars to indicate that they don't really have this \"number of observations\" property that we are after.\n\nMotivated by this, the concept of `size` was created in vctrs to capture the invariants that were desired.\nIn particular:\n\n-   It is the length of 1d vectors.\n-   It is the number of rows of data frames, matrices, and arrays.\n-   It throws error for non vectors.\n\nThe vctrs function, `vec_size()`, is the resulting implementation of this concept.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_size(df)\n#> [1] 4\n\nvec_size(df$x)\n#> [1] 4\n\nvec_size(mean)\n#> Error in `vec_size()`:\n#> ! `x` must be a vector, not a function.\n```\n:::\n\n## `vec_c()`\n\nArmed with the concept of size, let's take another look at `c(df, df)`.\nIf the length invariant for `c()` looks like:\n\n<center>\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(c(x, y)) == length(x) + length(y)\n```\n:::\n\n</center>\n\nthen imagine what would happen if `length()` was swapped with `vec_size()`:\n\n<center>\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_size(c(x, y)) =?= vec_size(x) + vec_size(y)\n```\n:::\n\n</center>\n\nDoes this invariant hold?\nFor 1d vectors, it does because `vec_size()` and `length()` are essentially the same.\nBut for data frames, we've seen that `vec_size()` and `length()` are different, and `c()` was built with `length()` in mind, so it might not.\nIn fact, looking at our original example of `c(df, df)` proves that it doesn't hold:\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_size(df) + vec_size(df)\n#> [1] 8\n\nvec_size(c(df, df))\n#> [1] 6\n```\n:::\n\nWe'd like this invariant to hold, but `c()` isn't the right tool for the job.\nInstead, an alternative, `vec_c()`, was built that builds off of `vec_size()` and this invariant.\nThe invariant that does hold actually looks like:\n\n<center>\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_size(vec_c(x, y)) == vec_size(x) + vec_size(y)\n```\n:::\n\n</center>\n\nSo what does `vec_c()` do?\nFor 1d vectors it acts like `c()`, as you might expect.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_c(1:2, 3)\n#> [1] 1 2 3\n```\n:::\n\nBut what about with `vec_c(df, df)`?\nBased on the fact that `vec_size(df) + vec_size(df) = 8`, at the very least we know it should return something with a size of 8.\nTo accomplish this, rather than coercing to a list and combining the columns together, `vec_c()` instead leaves them as data frames and *combines the rows*.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_c(df, df)\n#> # A tibble: 8 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> 2     2 b     x    \n#> 3     3 a     y    \n#> 4     4 a     x    \n#> 5     1 a     x    \n#> 6     2 b     x    \n#> 7     3 a     y    \n#> 8     4 a     x\n```\n:::\n\nIf you view a data frame as a vector of rows, this makes complete sense.\nWe start with a vector of 4 rows, and add another vector of 4 rows, so we should end up with a vector of 8 rows, i.e. a data frame with size 8.\n\nWhat happens if we combine `df` with a data frame containing one row but an entirely new column?\nAgain, we \"know\" from our size invariant that we should get something back with a size of 5.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_w <- tibble(w = 1)\n\nvec_c(df, df_w)\n#> # A tibble: 5 × 4\n#>       x y     z         w\n#>   <int> <chr> <chr> <dbl>\n#> 1     1 a     x        NA\n#> 2     2 b     x        NA\n#> 3     3 a     y        NA\n#> 4     4 a     x        NA\n#> 5    NA <NA>  <NA>      1\n```\n:::\n\nThe result is a data frame with 5 rows, and a union of the columns coming from each of the two individual data frames.\nWithout getting too much into it, the fact that the result is a \"tibble with 4 columns: x (int), y (chr), z (chr), and w (dbl)\" comes from the other half of what vctrs offers, the *prototype*.\n`vec_c()` found the \"common type\" between `df` and `df_w`, which is the union holding those 4 columns.\n\nWhat about combining `df` with something like the double vector, `c(1, 2)`?\nWe'd expect a size of 6 (4 from `df` and 2 from the vector), but we actually get an error because the size is only half of the story.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_c(df, c(1, 2))\n#> Error:\n#> ! Can't combine `..1` <tbl_df> and `..2` <double>.\n```\n:::\n\nIn this case, there is no common type between a data frame and a double vector, so you can't combine them together.\n\nCompare that with the result from `c()` which upholds its length invariant giving a result of length 5.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(df, c(1, 2))\n#> $x\n#> [1] 1 2 3 4\n#> \n#> $y\n#> [1] \"a\" \"b\" \"a\" \"a\"\n#> \n#> $z\n#> [1] \"x\" \"x\" \"y\" \"x\"\n#> \n#> [[4]]\n#> [1] 1\n#> \n#> [[5]]\n#> [1] 2\n```\n:::\n\n## `vec_match()`\n\nTreatment of a data frame as a vector of rows extends well past `vec_c()`, and bleeds into many other vctrs tools where we have been experimenting with this idea.\nAs one more example, we'll take a look at `match()`.\nIf you aren't familiar with `match()`, it tells you the location of `x` inside a `table`.\nAnother way to think about this is that you want to find a `needle` in a `haystack`.\nMore concretely:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Where is `\"a\"` inside the vector `c(\"b\", \"c\", \"a\", \"d\")`?\nmatch(x = \"a\", table = c(\"b\", \"c\", \"a\", \"d\"))\n#> [1] 3\n```\n:::\n\nNow imagine that I want to use a data frame as my `table`.\nI might be interested in locating a few particular rows inside that `table`.\n\n::: {.cell}\n\n```{.r .cell-code}\nneedles <- tibble(x = 3:4, y = c(\"a\", \"b\"), z = c(\"y\", \"y\"))\nhaystack <- df\n\nneedles\n#> # A tibble: 2 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     3 a     y    \n#> 2     4 b     y\n\nhaystack\n#> # A tibble: 4 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> 2     2 b     x    \n#> 3     3 a     y    \n#> 4     4 a     x\n```\n:::\n\nHere, the first row of `needles` is row 3 of the `haystack`, and the second row of `needles` is not in the `haystack` at all.\nLet's try with `match()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nmatch(needles, haystack)\n#> [1] NA NA NA\n```\n:::\n\n🤔 so what happened here?\nWith R's (completely reasonable) treatment of `needles` as a vector of columns, it essentially first converted `needles` and `haystack` into lists, and then tried to locate each column of `needles` inside `haystack`.\nThere were 3 columns, and none of them were found, so `NA` was returned 3 times.\nTo actually see a match, we could instead provide a list containing the `y` column of `haystack`.\n\n::: {.cell}\n\n```{.r .cell-code}\nmatch(list(haystack$y), haystack)\n#> [1] 2\n```\n:::\n\nIf we instead treat both `needles` and `haystack` as vectors of rows, what we are really trying to do is find one set of rows inside another set of rows.\nIn vctrs, we've created `vec_match()` for this.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_match(needles, haystack)\n#> [1]  3 NA\n```\n:::\n\nAgain, it's not that anything R is doing is *wrong*, or even that this is \"better\".\nThis just answers a different question by looking at a data frame from a different angle.\nAdditionally, we don't actually lose anything in vctrs by thinking about data frames in this way.\nIf we want the `match()` behavior, we can just `unclass()` our data frames to turn them into explicit lists, and then `vec_match()` works exactly the same.\n\n[Even though `c()` and `match()` treat data frames as vectors of columns, not all R functions do. At the end of the post I discuss how `split()` and `unique()` actually treat them as vectors of rows, and what the vctrs equivalents are.]{.aside}\n\n## `slide()`\n\nLastly, I'd like to show an example of a package that builds on top of vctrs principles.\n{slider} is my attempt at a package for working with \"window functions\", functions that enable some kind of \"rolling\" analysis.\nA moving average, rolling regression, and even a cumulative sum are all examples of usage of window functions.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(slider)\n```\n:::\n\n`slide()` works similarly to `purrr::map()` in that you provide it a vector, `.x`, and a function, `.f`, to apply to each slice of `.x`.\nOne difference is that you have additional options to control the window of `.x` you apply `.f` to.\nFor example, below we construct a sliding window of size 3, asking for \"the current value along with 2 values before this one\".\nThe function we apply is to just print out the current value of `.x` so we can see what is happening.\n\n::: {.cell}\n\n```{.r .cell-code}\nslide(1:5, ~.x, .before = 2)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 1 2\n#> \n#> [[3]]\n#> [1] 1 2 3\n#> \n#> [[4]]\n#> [1] 2 3 4\n#> \n#> [[5]]\n#> [1] 3 4 5\n```\n:::\n\nWe could also perform a rolling average by switching `~.x` for `mean`, and, like with purrr, replacing `slide()` with `slide_dbl()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nslide_dbl(1:5, mean, .before = 2)\n#> [1] 1.0 1.5 2.0 3.0 4.0\n```\n:::\n\nBecause `slide()` builds on vctrs, it is meaningful to talk about the invariants of the function.\nFor example, the size invariant of `slide()` is that:\n\n<center>\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_size(slide(.x)) == vec_size(.x)\n```\n:::\n\n</center>\n\nIn other words, `slide()` always returns an output that has the same *size* as its input.\nThis is similar to how `map()` works, with one major difference.\nLike `c()`, `map()` returns a vector with the same *length* as its input.\nThis means that `map()` treats a data frame as a vector of columns.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nmap(df, ~.x)\n#> $x\n#> [1] 1 2 3 4\n#> \n#> $y\n#> [1] \"a\" \"b\" \"a\" \"a\"\n#> \n#> $z\n#> [1] \"x\" \"x\" \"y\" \"x\"\n```\n:::\n\nA major breakthrough for me was that, to uphold the invariant, `slide()` must treat a data frame as a vector of rows, meaning that it should *iterate rowwise over .x*.\n\n::: {.cell}\n\n```{.r .cell-code}\nslide(df, ~.x)\n#> [[1]]\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> \n#> [[2]]\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     2 b     x    \n#> \n#> [[3]]\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     3 a     y    \n#> \n#> [[4]]\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     4 a     x\n```\n:::\n\nThis provides an alternative to some `pmap()` solutions that have been used previously, like the ones in Jenny Bryan's [GitHub repo](https://github.com/jennybc/row-oriented-workflows) of row oriented workflows.\nConsider this example modified from the repo, where you have a data frame of parameters that you want to pass on to `runif()` in order to call it multiple times with different parameter combinations.\nAdditionally, the column names don't currently match the argument names of `runif()`, so you either have to rename on the fly, or wrap it with a function.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nparameters <- tibble(\n  n = 1:3,\n  minimum = c(0, 10, 100),\n  maximum = c(1, 100, 1000)\n)\n\nset.seed(12)\n\nparameters %>%\n  rename(min = minimum, max = maximum) %>%\n  pmap(runif)\n#> [[1]]\n#> [1] 0.06936092\n#> \n#> [[2]]\n#> [1] 83.59977 94.83596\n#> \n#> [[3]]\n#> [1] 342.4437 252.4133 130.5061\n\nset.seed(12)\n\nmy_runif <- function(n, minimum, maximum) {\n  runif(n, minimum, maximum)\n}\n\npmap(parameters, my_runif)\n#> [[1]]\n#> [1] 0.06936092\n#> \n#> [[2]]\n#> [1] 83.59977 94.83596\n#> \n#> [[3]]\n#> [1] 342.4437 252.4133 130.5061\n```\n:::\n\nWith `slide()` being a row wise iterator, you have access to the entire data frame row at each iteration as `.x`, meaning you can just do:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12)\nslide(parameters, ~runif(n = .x$n, min = .x$minimum, max = .x$maximum))\n#> [[1]]\n#> [1] 0.06936092\n#> \n#> [[2]]\n#> [1] 83.59977 94.83596\n#> \n#> [[3]]\n#> [1] 342.4437 252.4133 130.5061\n```\n:::\n\n## Conclusion\n\nTreatment of a data frame as a vector of rows is a fairly novel concept in R, because of the way that data frames were originally implemented as a list of columns.\nBut viewing them in this way can be incredibly powerful, especially for data analysis work.\nI, for one, am looking forward to seeing this concept explored more in the future, both in vctrs and in other packages built on top of it.\n\n## Extra - `unique()` and `split()`\n\nOn the vctrs side, we are trying to be consistent in our treatment of data frames as vectors of rows.\nHowever, it is worth mentioning that there are some functions in R where data frames are already treated this way, rather than as a vector of columns.\nTwo in particular are `unique()` and `split()`.\n\n### `unique()`\n\nWith `unique()`, uniqueness is actually determined using data frame rows, not columns.\nLooking at columns `y` and `z` of `df`, we can see that rows 1 and 4 are duplicates.\nCalling `unique()` on this removes the duplicate row.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_yz <- df[, c(\"y\", \"z\")]\n\ndf_yz\n#> # A tibble: 4 × 2\n#>   y     z    \n#>   <chr> <chr>\n#> 1 a     x    \n#> 2 b     x    \n#> 3 a     y    \n#> 4 a     x\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(df_yz)\n#> # A tibble: 3 × 2\n#>   y     z    \n#>   <chr> <chr>\n#> 1 a     x    \n#> 2 b     x    \n#> 3 a     y\n```\n:::\n\nIt's actually pretty interesting to see how this one works.\nIf you look into `unique.data.frame()`, you'll see that it calls `duplicated.data.frame()`.\nIn there is this somewhat cryptic line that actually does the rowwise check:\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicated(\n  do.call(Map, `names<-`(c(list, x), NULL)), \n  fromLast = fromLast\n)\n```\n:::\n\nBreaking this down, it first combines the function `list()` with the data frame to end up with:\n\n::: {.cell}\n\n```{.r .cell-code}\nc(list, df_yz)\n#> [[1]]\n#> function (...)  .Primitive(\"list\")\n#> \n#> $y\n#> [1] \"a\" \"b\" \"a\" \"a\"\n#> \n#> $z\n#> [1] \"x\" \"x\" \"y\" \"x\"\n```\n:::\n\nwhich it then removes the names of:\n\n::: {.cell}\n\n```{.r .cell-code}\n`names<-`(c(list, df_yz), NULL)\n#> [[1]]\n#> function (...)  .Primitive(\"list\")\n#> \n#> [[2]]\n#> [1] \"a\" \"b\" \"a\" \"a\"\n#> \n#> [[3]]\n#> [1] \"x\" \"x\" \"y\" \"x\"\n```\n:::\n\nNext it uses `do.call()` to call `Map()`, which is a wrapper around `mapply()` meaning that it will repeatedly call `list()` on parallel elements of the columns of `df_yz`.\nVisually that means we end up with list elements holding the rows, which `duplicated()` is then run on to locate the duplicates.\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(Map, `names<-`(c(list, df_yz), NULL))\n#> $a\n#> $a[[1]]\n#> [1] \"a\"\n#> \n#> $a[[2]]\n#> [1] \"x\"\n#> \n#> \n#> $b\n#> $b[[1]]\n#> [1] \"b\"\n#> \n#> $b[[2]]\n#> [1] \"x\"\n#> \n#> \n#> $a\n#> $a[[1]]\n#> [1] \"a\"\n#> \n#> $a[[2]]\n#> [1] \"y\"\n#> \n#> \n#> $a\n#> $a[[1]]\n#> [1] \"a\"\n#> \n#> $a[[2]]\n#> [1] \"x\"\n\nduplicated(do.call(Map, `names<-`(c(list, df_yz), NULL)))\n#> [1] FALSE FALSE FALSE  TRUE\n```\n:::\n\nIn vctrs there is `vec_unique()`.\nBecause `unique()` already works row wise, they are essentially equivalent in terms of functionality with data frames.\nHowever, there are two key differences.\nFirst, because `vec_unique()`'s handling of data frames is in C, it does end up being faster.\n\n::: {.cell}\n\n```{.r .cell-code}\n# row bind df_yz 10000 times, making a 40000 row data frame\nlarge_df <- vec_rbind(!!!rep_len(list(df_yz), 10000))\ndim(large_df)\n#> [1] 40000     2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  unique(large_df),\n  vec_unique(large_df)\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## # A tibble: 2 x 6\n##   expression                min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr>           <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 unique(large_df)      28.38ms   31.6ms      31.7    1.42MB     137.\n## 2 vec_unique(large_df)   4.34ms    4.6ms     216.   429.61KB       0\n```\n:::\n\nSecond, `unique()` doesn't handle the idea of a *packed* data frame well.\nThis is a relatively new idea in the tidyverse, and it isn't one that we want to expose users to very much yet, but it is powerful.\nA packed data frame is a data frame where one of the columns is another data frame.\nThis is different from a list-column of data frames.\nYou can create one by providing `tibble()` another `tibble()` as a column along with a name for that data frame column.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_packed <- tibble(\n  x = tibble(\n    a = c(1, 1, 1, 3), \n    b = c(1, 1, 3, 3)\n  ), \n  y = c(1, 1, 1, 2)\n)\n\n# Both `$a` and `$b` are columns in the data frame column, `x`\ndf_packed\n#> # A tibble: 4 × 2\n#>     x$a    $b     y\n#>   <dbl> <dbl> <dbl>\n#> 1     1     1     1\n#> 2     1     1     1\n#> 3     1     3     1\n#> 4     3     3     2\n\n# `x` itself is another data frame\ndf_packed$x\n#> # A tibble: 4 × 2\n#>       a     b\n#>   <dbl> <dbl>\n#> 1     1     1\n#> 2     1     1\n#> 3     1     3\n#> 4     3     3\n```\n:::\n\n[Even though you can create one of these, as an end user there isn't much yet that you can do with them, so you shouldn't have to worry about this very much.]{.aside}\n\nLooking at `df_packed`, the unique rows are 1, 3, and 4, which `vec_unique()` can determine, but `unique()` doesn't correctly pick up on.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_unique(df_packed)\n#> # A tibble: 3 × 2\n#>     x$a    $b     y\n#>   <dbl> <dbl> <dbl>\n#> 1     1     1     1\n#> 2     1     3     1\n#> 3     3     3     2\n\nunique(df_packed)\n#> # A tibble: 3 × 2\n#>     x$a    $b     y\n#>   <dbl> <dbl> <dbl>\n#> 1     1     1     1\n#> 2     1     1     1\n#> 3     3     3     2\n```\n:::\n\nAs packed data frames become more prevalent in the tidyverse, it will be nice to have tools that handle them consistently.\n[For example, there is already `tidyr::pack()` and `tidyr::unpack()`, which helps power `tidyr::unnest()`.]{.aside}\n\n### `split()`\n\n`split(x, by)` will divide up `x` into groups using `by` to determine where the unique groups are.\nIt assumes `by` is a factor, and will coerce your input to a factor if it isn't already one.\nLike `unique()`, it will slice up a data frame by rows rather than by columns.\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit(df, df$y)\n#> $a\n#> # A tibble: 3 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> 2     3 a     y    \n#> 3     4 a     x    \n#> \n#> $b\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     2 b     x\n```\n:::\n\nOne thing about `split()` is that it uses the unique values as labels on the list elements.\nTo take a slightly different approach, `vec_split()` was created, which returns a data frame instead, holding the unique `key` values in their own parallel column.\n`vec_split()` returns a data frame to keep vctrs lightweight, but the print method for these can be a little complex, and I think tibble's print method does a nicer job.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_split <- vec_split(df, df$y)\ndf_split <- as_tibble(df_split)\n\ndf_split\n#> # A tibble: 2 × 2\n#>   key   val             \n#>   <chr> <list>          \n#> 1 a     <tibble [3 × 3]>\n#> 2 b     <tibble [1 × 3]>\n\ndf_split$val\n#> [[1]]\n#> # A tibble: 3 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> 2     3 a     y    \n#> 3     4 a     x    \n#> \n#> [[2]]\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     2 b     x\n```\n:::\n\nOne useful feature of `vec_split()` is that it doesn't expect a factor as the second argument, which means that a data frame can be provided to split by, and since uniqueness is determined row wise this allows us to split by multiple columns.\nThe `key` ends up as the unique rows of the data frame, meaning that the `key` is actually a data frame column, creating a packed data frame!\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_multi_split <- vec_split(df, df[c(\"y\", \"z\")])\ndf_multi_split <- as_tibble(df_multi_split)\n\ndf_multi_split\n#> # A tibble: 3 × 2\n#>   key$y $z    val             \n#>   <chr> <chr> <list>          \n#> 1 a     x     <tibble [2 × 3]>\n#> 2 b     x     <tibble [1 × 3]>\n#> 3 a     y     <tibble [1 × 3]>\n```\n:::\n\nTechnically you can provide `split()` a data frame to split `by`, but remember that it will try and treat it like a factor!\nSince the data frame is technically a list, it will run `interaction()` on it first to get a single factor it can use to split by.\nNotice that this gives a level for `b.y` which does not exist as a row in our data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[c(\"y\", \"z\")]\n#> # A tibble: 4 × 2\n#>   y     z    \n#>   <chr> <chr>\n#> 1 a     x    \n#> 2 b     x    \n#> 3 a     y    \n#> 4 a     x\n\ninteraction(df[c(\"y\", \"z\")])\n#> [1] a.x b.x a.y a.x\n#> Levels: a.x b.x a.y b.y\n```\n:::\n\nThis results in the following split, with a `b.y` element with no rows which we may or may not have wanted.\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit(df, df[c(\"y\", \"z\")])\n#> $a.x\n#> # A tibble: 2 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     1 a     x    \n#> 2     4 a     x    \n#> \n#> $b.x\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     2 b     x    \n#> \n#> $a.y\n#> # A tibble: 1 × 3\n#>       x y     z    \n#>   <int> <chr> <chr>\n#> 1     3 a     y    \n#> \n#> $b.y\n#> # A tibble: 0 × 3\n#> # … with 3 variables: x <int>, y <chr>, z <chr>\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}