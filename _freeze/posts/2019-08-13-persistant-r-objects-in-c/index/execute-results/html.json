{
  "hash": "f3d81c340299466ef7f14b0bb1e3e371",
  "result": {
    "markdown": "---\ntitle: Persistent R Objects in C\nauthor: Davis Vaughan\ndate: '2019-08-13'\nslug: persistant-r-objects-in-c\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## Introduction\n\nThis is another entry in my series of R + C based posts (you can see a full list [here](https://blog.davisvaughan.com/)).\nThis article focuses on a somewhat esoteric skill: constructing a global R object at the C level in a persistent way.\nBy \"persistent\", I mean that this object will only be created once (at package load time), and will be reusable throughout the life of the R session.\nYou'll be able to call it from other C files, and can even return the object to the R side.\nThe other \"trick\" that will be used is a way to run arbitrary C code on R package load, using `.onLoad()` + `.Call()`.\nThis is actually much more generic than what we will use it for in this article, so it is worth paying attention to in case you have other uses for it.\nAlong the way, I'll also use C header files to share C functions/objects between files, and discuss a bit about how I set up my R packages that use C code.\n\n[Most of these ideas are not my own. They are adaptations of ideas used by [Lionel Henry](https://twitter.com/_lionelhenry) in [`vctrs`](https://github.com/r-lib/vctrs) and [`rlang`](https://github.com/r-lib/rlang).]{.aside}\n\nWhy are persistent R objects callable from C useful?\nI can think of two reasons.\n\n-   The first is performance. You might have a simple R object (for instance, an integer vector holding `1`) that generally takes a small amount of time to create, but is generated and destroyed thousands of time across your C code base. To save a *little* bit of time, you might want to make this a persistent, unchangeable, global variable.\n-   The other is just for readability. Rather than having to deal with `PROTECT()`ing and `UNPROTECT()`ing common variables like `int_one` in the partial example below:\n\n::: {.cell}\n\n```{.c .cell-code}\nSEXP int_one = PROTECT(Rf_ScalarInteger(1));\n\n// Create an R list of length 1, put `int_one` in it\nSEXP result = PROTECT(Rf_allocVector(VECSXP, 1));\nSET_VECTOR_ELT(result, 0, int_one);\n\nUNPROTECT(2); // unprotect `int_one` and `result`\nreturn result;\n```\n:::\n\nYou can instead declare `int_one` as a global variable with a more permanent meaningful name, like `shared_int_one`, and use it without worrying about protection:\n\n::: {.cell}\n\n```{.c .cell-code}\nSEXP result = PROTECT(Rf_allocVector(VECSXP, 1));\n\n// can use `shared_int_one` without creating a new one\nSET_VECTOR_ELT(result, 0, shared_int_one);\n\nUNPROTECT(1); // only have to care about `result` protection\nreturn result;\n```\n:::\n\nWhen you have a large C based R package, these kinds of things really pay off in terms of increasing readability and cohesiveness of your package, especially if the global variable takes a few lines of C code to create each time.\nAdditionally, if naming conventions for these kinds of variables are used consistently, you'll immediately be able to recognize what `shared_empty_dbl` is without having to look it up in the code base.\nThis makes reading over C code a more pleasant experience.\n\nThe rest of this post will focus on creating a package that constructs some of these global variables.\nSpecifically, we will look at creating a shared empty integer and a shared character vector, and then we will see how to return them back to the R side.\nOne thing to keep in mind is that these kinds of things take a lot of setup on the C side for the first object, but adding subsequent objects is much simpler.\n\nIf you haven't read [Now You C Me](https://blog.davisvaughan.com/2019/03/02/now-you-c-me/), and you aren't too familiar with working on an R package with C code in it, you might want to go check out that post before continuing.\nIt will teach you the basics of working with an R package containing C code.\n\nThe final product is an R package called [cshared](https://github.com/DavisVaughan/cshared).\nIt contains one R function, `get_shared_objects()`.\nI'll discuss the bits and pieces of the package throughout the post, but that will be the ultimate reference for the end result.\n\n## Setup\n\nFirst, some setup.\nWe'll leverage `{usethis}` and `{devtools}` to get our new package up and running.\nI'm assuming you are working in RStudio for this.\nThe [Now You C Me](https://blog.davisvaughan.com/2019/03/02/now-you-c-me/) post describes these steps in much greater detail.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a new R package, cshared\nusethis::create_package(\"~/path/to/location/for/the/package/cshared\")\n\n# Use roxygen2\nusethis::use_roxygen_md()\n\n# As prompted by use_roxygen_md()\ndevtools::document()\n\n# Set up `cshared-package.R`, which also gives usethis a place to add extra\n# roxygen namespace tags, which is used by `use_c()` later on.\nusethis::use_package_doc()\n\n# Create a `src/shared.c` file, and add the all important registration info\n# to `cshared-package.R`\nusethis::use_c(\"shared\") \n\n# Initialize the C DLL, otherwise document() will complain\ndevtools::load_all(\".\")\n\n# As prompted by use_c()\ndevtools::document()\n```\n:::\n\n## Header Files\n\nAt this point you should be in an R package, and if you've opened `shared.c` you should see this staring at you:\n\n::: {.cell}\n\n```{.c .cell-code}\n#define R_NO_REMAP\n#include <R.h>\n#include <Rinternals.h>\n```\n:::\n\nI actually like to move these defines / includes into a package API header file that I can `#include` in all of my `.c` files, so personally I'm going to create a `cshared.h` file next, and move this over there.\nThere's not a shortcut for this, so in RStudio do `File -> New File -> C++ File` then save it as `cshared.h` in the `src/` folder.\nCopy those three lines to that file, and remove them from `shared.c`, replacing them with the following single include statement, which will have the same effect:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include \"cshared.h\"\n```\n:::\n\nTo prevent `cshared.h` from accidentally being included twice in the same file, we should also add some header include guards:\n\n::: {.cell}\n\n```{.c .cell-code}\n#ifndef CSHARED_H\n#define CSHARED_H\n\n#define R_NO_REMAP\n#include <R.h>\n#include <Rinternals.h>\n\n#endif\n```\n:::\n\n## C -\\> R\n\nOkay, now we have the basic structure set up, so let's wire up a C function to be callable from the R side.\nFor now, it will create a list containing an empty integer vector and a character vector holding `\"tidyverse\"`, and return it to the R side.\nLater it will return the same list but holding the shared versions of these objects.\nAdd the following function to `shared.c`:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include \"cshared.h\"\n\nSEXP cshared_get_shared_objects() {\n  // An empty integer vector\n  SEXP empty_int = PROTECT(Rf_allocVector(INTSXP, 0));\n\n  // Character vector of size 1, containing \"hello world\"\n  SEXP tidyverse = PROTECT(Rf_allocVector(STRSXP, 1));\n  SET_STRING_ELT(tidyverse, 0, Rf_mkChar(\"tidyverse\"));\n\n  // Initialize the output list, then insert our objects into it\n  SEXP out = PROTECT(Rf_allocVector(VECSXP, 2));\n  SET_VECTOR_ELT(out, 0, empty_int);\n  SET_VECTOR_ELT(out, 1, tidyverse);\n\n  // Must unprotect 3 PROTECT() calls before exiting!\n  UNPROTECT(3);\n  return out;\n}\n```\n:::\n\nTo call this from R, we need an `init.c` file that registers the C routine to the R side.\nWe've done something like this in the other blog post, so create `init.c` and fill it with:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include <R.h>\n#include <Rinternals.h>\n#include <stdlib.h> // for NULL\n#include <R_ext/Rdynload.h>\n\n/* .Call calls */\nextern SEXP cshared_get_shared_objects();\n\nstatic const R_CallMethodDef CallEntries[] = {\n  {\"cshared_get_shared_objects\", (DL_FUNC) &cshared_get_shared_objects, 0},\n  {NULL, NULL, 0}\n};\n\nvoid R_init_cshared(DllInfo *dll) {\n  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n  R_useDynamicSymbols(dll, FALSE);\n}\n```\n:::\n\nOver on the R side, we now need an R function that calls this `cshared_get_shared_objects` routine.\nCall `usethis::use_r(\"shared\")` and fill the resulting R file with:\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Get the shared objects\n#'\n#' @examples\n#'\n#' get_shared_objects()\n#'\n#' @export\nget_shared_objects <- function() {\n  .Call(cshared_get_shared_objects)\n}\n```\n:::\n\nLastly, run `devtools::load_all()` and `devtools::document()` to recompile the package and ensure that the shiny new `get_shared_objects()` is exported.\n\nYou should now be able to call:\n\n::: {.cell}\n\n```{.r .cell-code}\nget_shared_objects()\n#> [[1]]\n#> integer(0)\n#> \n#> [[2]]\n#> [1] \"tidyverse\"\n```\n:::\n\n## Let's Share\n\nThe next step is to replace our `empty_int` and `tidyverse` C variables with *shared* global variables that were created at package load time.\nThis will clean up our code a bit, and make `cshared_get_shared_object()` a bit easier to read.\nBut accomplishing this requires some thought!\nWhat we want is a way to initialize some C SEXP objects *when the R package is loaded*.\nGenerally, when we want to perform any action when a package is loaded we use the `.onLoad()` hook (see [`?.onLoad`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/ns-hooks.html) for more).\nTo make it actually initialize our C variables, we will use `.Call()` from inside `.onLoad()` to call a C function that does the initialization.\n\nThe general outline we are going to follow is:\n\n-   Create a C global variable, initialized to `NULL`.\n-   Create a C initialization function where we modify that global variable and set it to its actual value.\n-   Register this initialization function as a routine callable from R like we did with `cshared_get_shared_objects()`.\n-   Call it from `.onLoad()`.\n\nWe will start with `empty_int`, and then add `tidyverse`.\nI find that it is useful to store these global variables in a `utils.c` file, with a companion `utils.h` file that holds the definitions, allowing you to share them with other `.c` files.\nSo, to start, create `utils.h` and place the following in it:\n\n::: {.cell}\n\n```{.c .cell-code}\n#ifndef CSHARED_UTILS_H\n#define CSHARED_UTILS_H\n\n#include \"cshared.h\"\n\nSEXP cshared_shared_empty_int;\n\n#endif\n```\n:::\n\nAll this holds is the \"definition\" of the global object `cshared_shared_empty_int`.\nBy \"definition\" I just mean that we don't actually initialize the thing here, we just say \"hey, there is this thing called 'cshared_shared_empty_int', it is going to be a SEXP, and somewhere else it is going to be initialized, but if you `#include \"utils.h\"` you can use this thing\".\n\nNow create `utils.c`, where we will actually initialize the object:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include \"cshared.h\"\n#include \"utils.h\"\n\nSEXP cshared_shared_empty_int = NULL;\n\nSEXP cshared_init_utils() {\n  cshared_shared_empty_int = Rf_allocVector(INTSXP, 0);\n  R_PreserveObject(cshared_shared_empty_int);\n  MARK_NOT_MUTABLE(cshared_shared_empty_int);\n  \n  Rprintf(\"Initialized!\");\n  \n  return R_NilValue;\n}\n```\n:::\n\nHere, `SEXP cshared_shared_empty_int = NULL;` declares it as a global variable, but just sets it to `NULL`.\nWe can't set it directly to an empty integer vector because that isn't a \"compile time value\", it is a \"run time value\", meaning it can't be known before the program starts.\n\n`cshared_init_utils()` is the initialization function that we are eventually going to call from R in `.onLoad()`.\nIt does the following:\n\n-   Updates `cshared_shared_empty_int` to actually hold an empty integer vector.\n-   Calls `R_PreserveObject()` on it to ensure it isn't garbage collected.\n-   Calls `MARK_NOT_MUTABLE()` on it to ensure it can't be overwritten accidentally throughout the life of the R session.\n\nI've also added a print statement to prove that every time the package is loaded, this code is run.\n\nNow we have to register it to the R side, so modify `init.c` to export `cshared_init_utils()`.\nThat looks like:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include <R.h>\n#include <Rinternals.h>\n#include <stdlib.h> // for NULL\n#include <R_ext/Rdynload.h>\n\n/* .Call calls */\nextern SEXP cshared_get_shared_objects();\nextern void cshared_init_utils();\n\nstatic const R_CallMethodDef CallEntries[] = {\n  {\"cshared_get_shared_objects\", (DL_FUNC) &cshared_get_shared_objects, 0},\n  {\"cshared_init_utils\", (DL_FUNC) &cshared_init_utils, 0},\n  {NULL, NULL, 0}\n};\n\nvoid R_init_cshared(DllInfo *dll) {\n  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n  R_useDynamicSymbols(dll, FALSE);\n}\n```\n:::\n\nIf we `devtools::load_all()` now, we should have access to the `cshared_init_utils` routine object.\nThis is what we need to `.Call()` from `.onLoad()`.\nI generally put my `.onLoad()` in `zzz.R`, as it is an auxiliary function.\nIt should be pretty simple:\n\n::: {.cell}\n\n```{.r .cell-code}\n.onLoad <- function(libname, pkgname) {\n  .Call(cshared_init_utils)\n}\n```\n:::\n\nIf we `devtools::load_all()` again, this will trigger `.onLoad()`, and you should see...\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::load_all()\n#> Loading cshared\n#> Initialized!\n```\n:::\n\nGreat!\nSo now we know that code is being run.\nAt this point, go back and remove the `Rprintf()` line from `cshared_init_utils()`.\n\nHead back to `shared.c`.\nAt the top, just under `#include \"cshared.h\"`, add `#include \"utils.h\"` which will give you access to `cshared_shared_empty_int`.\nNow update `cshared_get_shared_objects()` to use it.\nThe function is becoming a bit easier to read!\n\n::: {.cell}\n\n```{.c .cell-code}\n#include \"cshared.h\"\n#include \"utils.h\" // To access `cshared_shared_empty_int`\n\nSEXP cshared_get_shared_objects() {\n  // Character vector of size 1, containing \"hello world\"\n  SEXP tidyverse = PROTECT(Rf_allocVector(STRSXP, 1));\n  SET_STRING_ELT(tidyverse, 0, Rf_mkChar(\"tidyverse\"));\n\n  SEXP out = PROTECT(Rf_allocVector(VECSXP, 2));\n  SET_VECTOR_ELT(out, 0, cshared_shared_empty_int); // <- using it here!\n  SET_VECTOR_ELT(out, 1, tidyverse);\n\n  UNPROTECT(2);\n  return out;\n}\n```\n:::\n\nAgain, run `devtools::load_all()` and call `get_shared_objects()`.\nIt should work as before, but this time it is returning a list holding the shared integer vector along with the tidyverse string!\n\n## The tidyverse string\n\nThe final step is to make the tidyverse string global and shared.\nNow that we have the infrastructure set up, this is much more straightforward.\nUpdate `utils.h` with a `strings_tidyverse` variable:\n\n::: {.cell}\n\n```{.c .cell-code}\n#ifndef CSHARED_UTILS_H\n#define CSHARED_UTILS_H\n\n#include \"cshared.h\"\n\nSEXP cshared_shared_empty_int;\n\nSEXP strings_tidyverse;\n\n#endif\n```\n:::\n\nUpdate `utils.c` with:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include \"cshared.h\"\n#include \"utils.h\"\n\nSEXP cshared_shared_empty_int = NULL;\n\n// This is new\nSEXP strings_tidyverse = NULL;\n\nSEXP cshared_init_utils() {\n  cshared_shared_empty_int = Rf_allocVector(INTSXP, 0);\n  R_PreserveObject(cshared_shared_empty_int);\n  MARK_NOT_MUTABLE(cshared_shared_empty_int);\n\n  // This is new\n  strings_tidyverse = Rf_allocVector(STRSXP, 1);\n  R_PreserveObject(strings_tidyverse);\n  SET_STRING_ELT(strings_tidyverse, 0, Rf_mkChar(\"tidyverse\"));\n  MARK_NOT_MUTABLE(strings_tidyverse);\n\n  return R_NilValue;\n}\n```\n:::\n\nThis does much of the same as what we did with `cshared_shared_empty_int`.\nIt creates a character vector of size 1 to overwrite the `NULL` global variable, preserves it, sets the first element value to `\"tidyverse\"`, then marks it as immutable.\n\nFinally we can go back to `shared.c` and use `strings_tidyverse`.\n\n::: {.cell}\n\n```{.c .cell-code}\n#include \"cshared.h\"\n#include \"utils.h\" // To access `cshared_shared_empty_int` and `strings_tidyverse`\n\nSEXP cshared_get_shared_objects() {\n  SEXP out = PROTECT(Rf_allocVector(VECSXP, 2));\n  SET_VECTOR_ELT(out, 0, cshared_shared_empty_int);\n  SET_VECTOR_ELT(out, 1, strings_tidyverse);\n\n  UNPROTECT(1);\n  return out;\n}\n```\n:::\n\nOne thing that I hope is clear is how much more focused `cshared_get_shared_objects()` is.\nIt's much easier to see what the purpose of the function is when you don't have to worry about creating these common shared objects.\nAdditionally, you only have to `UNPROTECT()` 1 value, `out`, which makes things slightly easier to keep track of.\nI also appreciate the fact that we can give our global objects evocative names like `strings_tidyverse`.\nIf I had another string object I wanted to make into a global variable, I could call it `strings_dplyr`.\nWhen I come across other C code that uses this variable, I immediately know what its value is because of this consistent naming convention.\n\n## Conclusion\n\nThese global variables are a neat trick for making code clearer, more internally consistent, and occasionally a bit faster.\nAdditionally, being able to call arbitrary C code on R package load is a useful tool in more ways than just global variable initialization (which we didn't get to explore in this post).\nIn a later post, I hope to show how to use this trick to initialize a variable holding a call object that let's you efficiently call an R function from C.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}