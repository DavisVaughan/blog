{
  "hash": "ad8a7117249c4fd9774b9e2f0580f03a",
  "result": {
    "markdown": "---\ntitle: ivs 0.1.0\nauthor: Davis Vaughan\ndate: '2022-04-20'\nslug: ivs-0-1-0\neditor_options: \n  chunk_output_type: console\n---\n\nI'm very excited to announce the first release of [ivs](https://davisvaughan.github.io/ivs/) (said, \"eye-vees\"), a package dedicated to working with intervals.\nIt introduces a new vector type, the **i**nterval **v**ector, which is generally just referred to as an **iv** throughout the package.\n\nYou can install ivs from CRAN with:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ivs\")\n```\n:::\n\nivs is loaded with tools for working with interval vectors.\nIn particular, it provides utilities for:\n\n-   Grouping / Merging overlapping intervals.\n\n-   Splitting intervals on overlapping endpoints.\n\n-   Determining how two ivs are related, i.e. does one interval precede, follow, or overlap another?\n\n-   Applying set theoretical operations like intersection, union, and complement on two ivs.\n\nThe rest of this blog post will explore some of this functionality through a number of practical examples.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ivs)\nlibrary(clock)\nlibrary(dplyr)\n```\n:::\n\n## Creating an interval vector\n\nInterval vectors are typically created from two parallel vectors representing the starts (inclusive) and ends (exclusive) of the intervals:\n\n::: {.cell}\n\n```{.r .cell-code}\nstarts <- c(1, 5, 10, 3)\nends <- c(6, 9, 12, 4)\n\niv(starts, ends)\n#> <iv<double>[4]>\n#> [1] [1, 6)   [5, 9)   [10, 12) [3, 4)\n```\n:::\n\nivs is designed to play nicely with the tidyverse, and most of the time `start` and `end` will already be columns in an existing data frame.\n\nivs is also designed to be *generic*.\nIt is built on top of [vctrs](https://vctrs.r-lib.org), which gives it the ability to use any comparable type as the start/end vectors.\n\nThis includes dates and date-times:\n\n::: {.cell}\n\n```{.r .cell-code}\nstarts <- as.Date(\"2019-01-01\") + 0:2\nends <- starts + c(2, 5, 10)\n\niv(starts, ends)\n#> <iv<date>[3]>\n#> [1] [2019-01-01, 2019-01-03) [2019-01-02, 2019-01-07) [2019-01-03, 2019-01-13)\n```\n:::\n\nthe `integer64` type from [bit64](https://cran.r-project.org/web/packages/bit64/index.html):\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- bit64::as.integer64(\"900000000000\")\nend <- start + 1234\n\niv(start, end)\n#> <iv<integer64>[1]>\n#> [1] [900000000000, 900000001234)\n```\n:::\n\nor the `year_month_day` type from [clock](https://clock.r-lib.org):\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- year_month_day(c(2019, 2020), c(1, 3))\nend <- year_month_day(c(2020, 2020), c(2, 6))\n\niv(start, end)\n#> <iv<year_month_day<month>>[2]>\n#> [1] [2019-01, 2020-02) [2020-03, 2020-06)\n```\n:::\n\nInterval vectors are always composed of right-open intervals, and each individual interval in the vector must satisfy `start < end`.\nI say more on the practical reasons for this [in the Getting Started vignette](https://davisvaughan.github.io/ivs/articles/ivs.html#structure) if you are interested in learning more.\n\n## Grouping by overlaps\n\nOne of the key features of ivs is that it makes identifying and merging overlaps as easy as possible.\n\nImagine you work for AWS (Amazon Web Services) and you have a database that tracks costs racked up by users that are utilizing your services.\nThe date ranges below represent the intervals over which the cost was accrued, and the intervals don't overlap for a given `(user, service)` pair.\n\n::: {.cell}\n\n```{.r .cell-code}\ncosts <- tribble(\n  ~user, ~service, ~from, ~to, ~cost,\n  1L, \"a\", \"2019-01-01\", \"2019-01-05\", 200.5,\n  1L, \"a\", \"2019-01-12\", \"2019-01-13\", 15.6,\n  1L, \"b\", \"2019-01-03\", \"2019-01-10\", 500.3,\n  2L, \"a\", \"2019-01-02\", \"2019-01-03\", 25.6,\n  2L, \"b\", \"2019-01-01\", \"2019-01-06\", 217.3,\n  2L, \"c\", \"2019-01-03\", \"2019-01-04\", 30,\n  2L, \"c\", \"2019-01-05\", \"2019-01-07\", 66.2\n) %>%\n  mutate(\n    from = as.Date(from),\n    to = as.Date(to)\n  )\n\ncosts\n#> # A tibble: 7 × 5\n#>    user service from       to          cost\n#>   <int> <chr>   <date>     <date>     <dbl>\n#> 1     1 a       2019-01-01 2019-01-05 200. \n#> 2     1 a       2019-01-12 2019-01-13  15.6\n#> 3     1 b       2019-01-03 2019-01-10 500. \n#> 4     2 a       2019-01-02 2019-01-03  25.6\n#> 5     2 b       2019-01-01 2019-01-06 217. \n#> 6     2 c       2019-01-03 2019-01-04  30  \n#> 7     2 c       2019-01-05 2019-01-07  66.2\n```\n:::\n\nYou might be interested in identifying the contiguous blocks of time that a particular service was in use, regardless of who was using it.\nIn graphical form, that might look like this (notice how the overlapping `a` and overlapping `b` intervals have been combined):\n\n![](omnigraffle/ivs/groups.png)\n\nTo solve this problem, we will first convert our `from/to` dates into a true interval vector using `iv()`.\n\n::: {.cell}\n\n```{.r .cell-code}\ncosts <- costs %>%\n  mutate(\n    interval = iv(from, to), \n    .keep = \"unused\"\n  )\n\ncosts\n#> # A tibble: 7 × 4\n#>    user service  cost                 interval\n#>   <int> <chr>   <dbl>               <iv<date>>\n#> 1     1 a       200.  [2019-01-01, 2019-01-05)\n#> 2     1 a        15.6 [2019-01-12, 2019-01-13)\n#> 3     1 b       500.  [2019-01-03, 2019-01-10)\n#> 4     2 a        25.6 [2019-01-02, 2019-01-03)\n#> 5     2 b       217.  [2019-01-01, 2019-01-06)\n#> 6     2 c        30   [2019-01-03, 2019-01-04)\n#> 7     2 c        66.2 [2019-01-05, 2019-01-07)\n```\n:::\n\nNext, we'll use `iv_groups()` on the `interval` column to merge together all of the overlapping intervals.\nIt returns the intervals that remain after all of the overlaps have been merged.\nSince we want to do this on a per-service basis, we'll group by `service`.\n\n::: {.cell}\n\n```{.r .cell-code}\nservices <- costs %>%\n  group_by(service) %>%\n  summarise(interval = iv_groups(interval), .groups = \"keep\")\n\n# Note how this merged the two overlapping `service == \"b\"` intervals\n# of [2019-01-03, 2019-01-10) and [2019-01-01, 2019-01-06) into one\n# wider interval of [2019-01-01, 2019-01-10)\nservices \n#> # A tibble: 5 × 2\n#> # Groups:   service [3]\n#>   service                 interval\n#>   <chr>                 <iv<date>>\n#> 1 a       [2019-01-01, 2019-01-05)\n#> 2 a       [2019-01-12, 2019-01-13)\n#> 3 b       [2019-01-01, 2019-01-10)\n#> 4 c       [2019-01-03, 2019-01-04)\n#> 5 c       [2019-01-05, 2019-01-07)\n```\n:::\n\nNote that we used `summarise()` here rather than `mutate()`.\n`iv_groups()` will return a new interval vector that is *shorter* than the original input, so we can't use `mutate()`.\nInstead, we are taking advantage of the relatively new feature of `summarise()` which allows you to return a per-group result with length \\>1.\n\nYou also might be interested in the intervals corresponding to when a service *wasn't* being used.\nI'm getting ahead of myself a little bit, but you could use one of the set operation functions, `iv_complement()`, for this.\nWe'll provide (optional) lower and upper bounds for the universe over which to take the complement.\n\n::: {.cell}\n\n```{.r .cell-code}\nlower <- as.Date(\"2019-01-01\")\nupper <- as.Date(\"2019-01-15\")\n\nservices %>%\n  summarise(\n    not_in_use = iv_complement(interval, lower = lower, upper = upper),\n    .groups = \"drop\"\n  )\n#> # A tibble: 6 × 2\n#>   service               not_in_use\n#>   <chr>                 <iv<date>>\n#> 1 a       [2019-01-05, 2019-01-12)\n#> 2 a       [2019-01-13, 2019-01-15)\n#> 3 b       [2019-01-10, 2019-01-15)\n#> 4 c       [2019-01-01, 2019-01-03)\n#> 5 c       [2019-01-04, 2019-01-05)\n#> 6 c       [2019-01-07, 2019-01-15)\n```\n:::\n\nLet's go back to `costs` and answer one more question.\nLet's say you don't care about `service` anymore, and you just want to aggregate the costs over any contiguous date range for a particular `user`.\nFor example, user `1` used service `a` and `b` simultaneously, so you'd like to combine those costs into a single larger interval.\n\nWe can try to use `iv_groups()` here, but this isn't quite what we need because it doesn't give us a chance to aggregate the costs:\n\n::: {.cell}\n\n```{.r .cell-code}\ncosts %>%\n  group_by(user) %>%\n  summarise(interval = iv_groups(interval), .groups = \"drop\")\n#> # A tibble: 3 × 2\n#>    user                 interval\n#>   <int>               <iv<date>>\n#> 1     1 [2019-01-01, 2019-01-10)\n#> 2     1 [2019-01-12, 2019-01-13)\n#> 3     2 [2019-01-01, 2019-01-07)\n```\n:::\n\nInstead, we'll use `iv_identify_group()`.\nThis returns a new interval vector that has the same length as the old one, and identifies which of the 3 groups returned above that the original interval falls in.\n\n::: {.cell}\n\n```{.r .cell-code}\nusers <- costs %>%\n  select(-service) %>%\n  group_by(user) %>%\n  mutate(user_interval = iv_identify_group(interval))\n\nusers\n#> # A tibble: 7 × 4\n#> # Groups:   user [2]\n#>    user  cost                 interval            user_interval\n#>   <int> <dbl>               <iv<date>>               <iv<date>>\n#> 1     1 200.  [2019-01-01, 2019-01-05) [2019-01-01, 2019-01-10)\n#> 2     1  15.6 [2019-01-12, 2019-01-13) [2019-01-12, 2019-01-13)\n#> 3     1 500.  [2019-01-03, 2019-01-10) [2019-01-01, 2019-01-10)\n#> 4     2  25.6 [2019-01-02, 2019-01-03) [2019-01-01, 2019-01-07)\n#> 5     2 217.  [2019-01-01, 2019-01-06) [2019-01-01, 2019-01-07)\n#> 6     2  30   [2019-01-03, 2019-01-04) [2019-01-01, 2019-01-07)\n#> 7     2  66.2 [2019-01-05, 2019-01-07) [2019-01-01, 2019-01-07)\n```\n:::\n\nThis gives us something we can group on so we can `sum()` up the costs:\n\n::: {.cell}\n\n```{.r .cell-code}\nusers %>%\n  group_by(user, user_interval) %>%\n  summarise(cost = sum(cost), .groups = \"drop\")\n#> # A tibble: 3 × 3\n#>    user            user_interval  cost\n#>   <int>               <iv<date>> <dbl>\n#> 1     1 [2019-01-01, 2019-01-10) 701. \n#> 2     1 [2019-01-12, 2019-01-13)  15.6\n#> 3     2 [2019-01-01, 2019-01-07) 339.\n```\n:::\n\n## Locating overlaps\n\nWhile `iv_groups()` is useful for working with overlaps in a single interval vector, you might also find yourself in a situation where you need to identify relationships between multiple vectors.\nThis might be between two interval vectors (where you are detecting if one overlaps another in some way) or between a regular vector and an interval vector (where you want to know if the elements of the vector lie between any of the intervals).\n\nFor example, you might want to locate where these two interval vectors overlap:\n\n::: {.cell}\n\n```{.r .cell-code}\n# iv_pairs() is a useful way to create small ivs from individual intervals\nneedles <- iv_pairs(c(1, 5), c(3, 7), c(10, 12))\nneedles\n#> <iv<double>[3]>\n#> [1] [1, 5)   [3, 7)   [10, 12)\n\nhaystack <- iv_pairs(c(1, 6), c(12, 13), c(1, 2), c(7, 8), c(4, 5))\nhaystack\n#> <iv<double>[5]>\n#> [1] [1, 6)   [12, 13) [1, 2)   [7, 8)   [4, 5)\n```\n:::\n\n![](omnigraffle/ivs/locate.png)\n\nIdeally you'd like to be notified of the fact that `[1, 5)` from `needles` overlaps with `[1, 6)`, `[1, 2)` and `[4, 5)` from `haystack`.\n`iv_locate_overlaps()` allows you to do exactly this, and returns a data frame of the locations where the two interval vectors overlap.\n\n::: {.cell}\n\n```{.r .cell-code}\nlocations <- iv_locate_overlaps(needles, haystack)\nlocations\n#>   needles haystack\n#> 1       1        1\n#> 2       1        3\n#> 3       1        5\n#> 4       2        1\n#> 5       2        5\n#> 6       3       NA\n```\n:::\n\nYou can hand this data frame off to `iv_align()`, along with the original inputs, and it will join them together based on their overlapping locations:\n\n::: {.cell}\n\n```{.r .cell-code}\niv_align(needles, haystack, locations = locations)\n#>    needles haystack\n#> 1   [1, 5)   [1, 6)\n#> 2   [1, 5)   [1, 2)\n#> 3   [1, 5)   [4, 5)\n#> 4   [3, 7)   [1, 6)\n#> 5   [3, 7)   [4, 5)\n#> 6 [10, 12) [NA, NA)\n```\n:::\n\nYou'll notice that `[10, 12)` from `needles` didn't overlap with anything from `haystack`, so it was aligned with a missing interval.\n\n`iv_locate_overlaps()` has a number of options to tweak the type of overlap you are looking for.\nFor example, you can change the `type` from its default value of `\"any\"` overlap to instead restrict it to cases where `needles` is `\"within\"` the `haystack` intervals, or to cases where it `\"contains\"` them.\nYou can also change what happens when there is `no_match`, like with `[10, 12)` from above.\nIf you don't want to see unmatched needles in the result, you can `\"drop\"` them:\n\n::: {.cell}\n\n```{.r .cell-code}\nlocations <- iv_locate_overlaps(needles, haystack, no_match = \"drop\")\niv_align(needles, haystack, locations = locations)\n#>   needles haystack\n#> 1  [1, 5)   [1, 6)\n#> 2  [1, 5)   [1, 2)\n#> 3  [1, 5)   [4, 5)\n#> 4  [3, 7)   [1, 6)\n#> 5  [3, 7)   [4, 5)\n```\n:::\n\nOther related functionality includes:\n\n-   `iv_locate_precedes()` and `iv_locate_follows()` to determine where one iv precedes or follows another.\n\n-   `iv_locate_between()` to determine if elements of a vector fall *between* the intervals in an iv.\n\n-   `iv_overlaps()` which works like `iv_locate_overlaps()` but just returns a logical vector detecting if there were any overlapping intervals at all.\n\n## Counting overlaps\n\nSometimes you just need the counts of the number of overlaps rather than the actual locations of them.\nFor example, say your business has a subscription service and you'd like to compute a rolling monthly count of the total number of currently active subscriptions (i.e. in January 2019, how many subscriptions were active?).\nCustomers are only allowed to have one subscription active at once, but they may cancel it and reactivate it at any time.\nIf a customer was active at any point during the month, then they are counted in that month.\n\n::: {.cell}\n\n```{.r .cell-code}\nenrollments <- tribble(\n  ~name,      ~start,          ~end,\n  \"Amy\",      \"1, Jan, 2017\",  \"30, Jul, 2018\",\n  \"Franklin\", \"1, Jan, 2017\",  \"19, Feb, 2017\",\n  \"Franklin\", \"5, Jun, 2017\",  \"4, Feb, 2018\",\n  \"Franklin\", \"21, Oct, 2018\", \"9, Mar, 2019\",\n  \"Samir\",    \"1, Jan, 2017\",  \"4, Feb, 2017\",\n  \"Samir\",    \"5, Apr, 2017\",  \"12, Jun, 2018\"\n)\n\n# Parse these into \"day\" precision year-month-day objects\nenrollments <- enrollments %>%\n  mutate(\n    start = year_month_day_parse(start, format = \"%d, %b, %Y\"),\n    end = year_month_day_parse(end, format = \"%d, %b, %Y\"),\n  )\n\nenrollments\n#> # A tibble: 6 × 3\n#>   name     start      end       \n#>   <chr>    <ymd<day>> <ymd<day>>\n#> 1 Amy      2017-01-01 2018-07-30\n#> 2 Franklin 2017-01-01 2017-02-19\n#> 3 Franklin 2017-06-05 2018-02-04\n#> 4 Franklin 2018-10-21 2019-03-09\n#> 5 Samir    2017-01-01 2017-02-04\n#> 6 Samir    2017-04-05 2018-06-12\n```\n:::\n\nEven though we have day precision information, we only actually need month precision intervals to answer this question.\nWe'll use `calendar_narrow()` from clock to convert our `\"day\"` precision dates to `\"month\"` precision ones to reflect this.\nWe'll also add 1 month to the `end` intervals to reflect the fact that the end month is open (remember, ivs are half-open).\n\n::: {.cell}\n\n```{.r .cell-code}\nenrollments <- enrollments %>%\n  mutate(\n    start = calendar_narrow(start, \"month\"),\n    end = calendar_narrow(end, \"month\") + 1L\n  )\n\nenrollments\n#> # A tibble: 6 × 3\n#>   name     start        end         \n#>   <chr>    <ymd<month>> <ymd<month>>\n#> 1 Amy      2017-01      2018-08     \n#> 2 Franklin 2017-01      2017-03     \n#> 3 Franklin 2017-06      2018-03     \n#> 4 Franklin 2018-10      2019-04     \n#> 5 Samir    2017-01      2017-03     \n#> 6 Samir    2017-04      2018-07\n\nenrollments <- enrollments %>%\n  mutate(active = iv(start, end), .keep = \"unused\")\n\nenrollments\n#> # A tibble: 6 × 2\n#>   name                 active\n#>   <chr>      <iv<ymd<month>>>\n#> 1 Amy      [2017-01, 2018-08)\n#> 2 Franklin [2017-01, 2017-03)\n#> 3 Franklin [2017-06, 2018-03)\n#> 4 Franklin [2018-10, 2019-04)\n#> 5 Samir    [2017-01, 2017-03)\n#> 6 Samir    [2017-04, 2018-07)\n```\n:::\n\nTo answer this question, we are going to need to create a sequential vector of months that span the entire range of intervals.\nThis starts at the smallest `start` and goes to the largest `end`.\nBecause the `end` is half-open, there won't be any hits for that month, so we won't include it.\n\n::: {.cell}\n\n```{.r .cell-code}\nbounds <- range(enrollments$active)\nlower <- iv_start(bounds[[1]])\nupper <- iv_end(bounds[[2]]) - 1L\n\nmonths <- tibble(month = seq(lower, upper, by = 1))\n\nmonths\n#> # A tibble: 27 × 1\n#>    month       \n#>    <ymd<month>>\n#>  1 2017-01     \n#>  2 2017-02     \n#>  3 2017-03     \n#>  4 2017-04     \n#>  5 2017-05     \n#>  6 2017-06     \n#>  7 2017-07     \n#>  8 2017-08     \n#>  9 2017-09     \n#> 10 2017-10     \n#> # … with 17 more rows\n```\n:::\n\nTo finish up, we need to add a column to `months` to represent the number of subscriptions that were active in that month.\nTo do this we can use `iv_count_between()`, which returns an integer vector corresponding to the number of times the `i`-th month fell between any of the intervals in the active subscription interval vector.\n\n::: {.cell}\n\n```{.r .cell-code}\nmonths <- months %>%\n  mutate(count = iv_count_between(month, enrollments$active))\n\nmonths\n#> # A tibble: 27 × 2\n#>    month        count\n#>    <ymd<month>> <int>\n#>  1 2017-01          3\n#>  2 2017-02          3\n#>  3 2017-03          1\n#>  4 2017-04          2\n#>  5 2017-05          2\n#>  6 2017-06          3\n#>  7 2017-07          3\n#>  8 2017-08          3\n#>  9 2017-09          3\n#> 10 2017-10          3\n#> # … with 17 more rows\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/number-of-active-enrollments-1.png){fig-alt='Line chart of monthly enrollments over time with a slight decrease in enrollments over the years' width=672}\n:::\n:::\n\nAlso available are `iv_count_overlaps()`, `iv_count_precedes()`, and `iv_count_follows()` for counting relationships between two ivs.\n\n## Set operations\n\nThere are a number of set theoretical operations that you can use on ivs.\nThese are:\n\n-   `iv_complement()`\n\n-   `iv_union()`\n\n-   `iv_intersect()`\n\n-   `iv_difference()`\n\n-   `iv_symmetric_difference()`\n\n`iv_complement()` works on a single iv, while all the others work on two ivs at a time.\nThe easiest way to think about these functions is to imagine `iv_groups()` being called on each of the inputs first (to reduce them down to their minimal form) before applying the operation.\n\n`iv_complement()` computes the set complement of the intervals in a single iv.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- iv_pairs(c(1, 3), c(2, 5), c(10, 12), c(13, 15))\nx\n#> <iv<double>[4]>\n#> [1] [1, 3)   [2, 5)   [10, 12) [13, 15)\n\niv_complement(x)\n#> <iv<double>[2]>\n#> [1] [5, 10)  [12, 13)\n```\n:::\n\n![](omnigraffle/ivs/complement.png)\n\nBy default, `iv_complement()` uses the smallest/largest values of its input as the bounds to compute the complement over, but, as we showed back in the `iv_groups()` section, you can supply bounds explicitly with `lower` and `upper`:\n\n::: {.cell}\n\n```{.r .cell-code}\niv_complement(x, upper = 20)\n#> <iv<double>[3]>\n#> [1] [5, 10)  [12, 13) [15, 20)\n```\n:::\n\n![](omnigraffle/ivs/complement-upper.png)\n\n`iv_union()` takes the union of two ivs.\nIt answers the question, \"Which intervals are in `x` or `y`?\"\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- iv_pairs(c(4, 5), c(13, 16), c(14, 18))\n\nx\n#> <iv<double>[4]>\n#> [1] [1, 3)   [2, 5)   [10, 12) [13, 15)\ny\n#> <iv<double>[3]>\n#> [1] [4, 5)   [13, 16) [14, 18)\n\niv_union(x, y)\n#> <iv<double>[3]>\n#> [1] [1, 5)   [10, 12) [13, 18)\n```\n:::\n\n![](omnigraffle/ivs/union.png)\n\n`iv_intersect()` takes the intersection of two ivs.\nIt answers the question, \"Which intervals are in `x` and `y`?\"\n\n::: {.cell}\n\n```{.r .cell-code}\niv_intersect(x, y)\n#> <iv<double>[2]>\n#> [1] [4, 5)   [13, 15)\n```\n:::\n\n![](omnigraffle/ivs/intersect.png)\n\n`iv_difference()` takes the asymmetrical difference of two ivs.\nIt answers the question, \"Which intervals are in `x` but not `y`?\"\n\n::: {.cell}\n\n```{.r .cell-code}\niv_difference(x, y)\n#> <iv<double>[2]>\n#> [1] [1, 4)   [10, 12)\n```\n:::\n\n![](omnigraffle/ivs/difference.png)\n\n## Inspiration\n\nivs was inspired by quite a few places!\n\n-   [IRanges](https://github.com/Bioconductor/IRanges) is a Bioconductor package that served as the biggest inspiration for this package.\n    It is mainly focused on integer intervals for use with genomics, and uses S4 in a way that unfortunately means that their interval objects can't currently be used as columns in a tibble, but is otherwise a really impressive package.\n\n-   [Maintaining Knowledge about Temporal Intervals](https://cse.unl.edu/~choueiry/Documents/Allen-CACM1983.pdf) is a paper by James Allen that a number of these functions are based on.\n    It is also a great primer on integer algebra.\n\n-   [data.table](https://github.com/Rdatatable/data.table) contains a function named `foverlaps()` for detecting different types of overlaps.\n    It was also inspired by `IRanges::findOverlaps()`.\n    They also have support for non-equi joins, which can also accomplish some of this.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}