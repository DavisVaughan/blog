{
  "hash": "03a0e237bb3666b483b2ce8039f4dcf5",
  "result": {
    "markdown": "---\ntitle: \"Financial Numerical Methods - Part 1: Vectorized Stock Price Simulation\"\nauthor: \"Davis Vaughan\"\ndate: '2017-08-28'\n---\n\n### Why am I posting about this?\n\nSchool has started up, and I'm in a class called *Financial Computing*.\nI thought it might be interesting to share some of my assignments and explain what I learn along the way.\nMost of the posts won't be describing the [Stochastic Calculus](https://www.quantstart.com/articles/Introduction-to-Stochastic-Calculus) involved in each assignment, but will instead focus on the details of the implementation in R.\nI don't claim to have the best way for any of these assignments, but perhaps you can learn something!\n\n### What are we doing today?\n\nIn this post, I'll work through simulating paths of a stock that follows the log normal distribution used in the [Black Scholes model](https://www.coursera.org/learn/financial-engineering-1/lecture/pPqjt/the-black-scholes-model).\nImportantly, I'll explain my thought process as I tried to optimize the implementation from loops to vectors.\n\nAs an added bonus, at the very bottom is some extra content on a basic function that I have created to replicate the concept of *broadcasting* from Python.\nSomeone could (should?) probably create an entire package out of this idea.\n\n### The Model\n\nUnder the Black Scholes model, the stock price, $S_t$, at time `t` follows a Geometric Brownian Motion, which means that it satisfies the Stochastic Differential Equation:\n\n$$ dS_t = r S_t dt + \\sigma S_t dW_t $$\n\nWhere:\n\n-   $r =$ Drift - The average log return per time unit\n-   $\\sigma =$ Volatility - How much variance is in that drift\n-   $W_t =$ Brownian Motion - Random noise from a normal distribution with mean `0` and variance `t`\n\nInterestingly, we actually have the solution to this equation (one of the few we have analytical solutions for):\n\n$$ S_t = S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) t + \\sigma W_t} $$\n\nMore generally, this can be written as a formula providing us with the recursive equation:\n\n$$ S_{t_i} = S_{t_{i-1}} \\times e^{(r - \\frac{1}{2} \\sigma^2) ({t_i - t_{i-1}}) + \\sigma (W_{t_i} - W_{t_{i-1}}) } $$\n\nIf you want to know how to get the solution, [this](https://www.quantstart.com/articles/Geometric-Brownian-Motion) is a pretty good explanation, but be prepared to learn about [Ito's Lemma](http://www.math.tamu.edu/~stecher/425/Sp12/brownianMotion.pdf).\n\n### Really, dude?\n\nOkay, that's a lot without any explanation, and I get that.\nBut the point of this post is more to explain how to simulate paths of $S_t$.\nSo how do we do that?\n\n-   We will start from time 0 with an initial stock price, then we will generate the next stock price from that using the recursive formula, and so on.\n-   The only random piece is the brownian motion increment (`dW`), which we will generate at each time point using draws from a normal distribution.\n-   The time increment will be a constant value (`dt`) to keep things simple.\n\nI was given some starting parameters:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set a seed too so I can reproduce the exact numbers\nset.seed(123)\n\n# Parameters\nr       <- 0.028\nsigma   <- 0.255\ntime_T  <- 0.5\ndt      <- 1/12\nt_total <- time_T / dt\ns_0     <- 100\nN       <- 10000\n```\n:::\n\nWhere `time_T` and `dt` mean each simulation path will go from time 0 to `time_T` by increments of `dt`.\nDividing `time_T / dt` gets us the total number of time steps required.\n`N` is the number of paths to simulate.\n\n### First attempt\n\nWe all know loops are to be avoided when you can in R, and that you should instead vectorize the operations.\nAt first, I thought this wasn't going to be possible, as this is a recursive type of formula where the next value relies on the previous one.\nWith that in mind, I created the following implementation.\n\nFirst off, set up a matrix to fill with the 10000 simulations (one per row), each one having 6 time steps (7 columns total including the initial stock price).\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a 10000x7 matrix of NA's to fill in\n# Each row is a simulation\ns <- matrix(NA_real_, nrow = N, ncol = t_total+1)\n\n# The first column is just the initial price\ns[,1] <- s_0\n\nhead(s)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n#> [1,]  100   NA   NA   NA   NA   NA   NA\n#> [2,]  100   NA   NA   NA   NA   NA   NA\n#> [3,]  100   NA   NA   NA   NA   NA   NA\n#> [4,]  100   NA   NA   NA   NA   NA   NA\n#> [5,]  100   NA   NA   NA   NA   NA   NA\n#> [6,]  100   NA   NA   NA   NA   NA   NA\n```\n:::\n\nSo far so good, now let's create a matrix for `dW`, our brownian motion increments.\nA *very* important fact is that these are all independent of each other, so the generation of them is straightforward.\nEach increment:\n\n$$ W_{t_i} - W_{t_{i-1}} $$\n\ncan be drawn from a normal distribution with mean 0 and variance $t_i - t_{i-1}$ (which is what I have defined as `dt` because it is a constant).\n\n::: {.cell}\n\n```{.r .cell-code}\n# ~N(0, dt)\n# To fill in 10000 simulations, and move forward 6 steps, we need a 10000x6 matrix\ndW <- rnorm(N * t_total, mean = 0, sd = sqrt(dt))\ndW <- matrix(dW, N, t_total)\nhead(dW)\n#>             [,1]        [,2]        [,3]        [,4]        [,5]        [,6]\n#> [1,] -0.16179538  0.68436942 -0.24141807 -0.05588936  0.13929365  0.07493710\n#> [2,] -0.06644652 -0.04815446 -0.06367394  0.07452070  0.20824004  0.26486253\n#> [3,]  0.44996033  0.26759071 -0.60723241 -0.15539745 -0.14658701 -0.20851535\n#> [4,]  0.02035402 -0.16401128 -0.48145457 -0.34036612 -0.01867981 -0.23333150\n#> [5,]  0.03732215  0.06497791 -0.31695458  0.25999452  0.37589000 -0.04080481\n#> [6,]  0.49509662  0.32677618 -0.48082343 -0.00469084 -0.06311503  0.65154366\n```\n:::\n\nBased on this setup, I thought I would need a loop.\nThe algorithm would step through the 10000 simulations all at once, but would have to loop through the 6 time steps one at a time, because each time step depended on the previous one.\nSo, following the formula (below again for reference) I did this:\n\n$$ S_{t_i} = S_{t_{i-1}} \\times e^{(r - \\frac{1}{2} \\sigma^2) ({t_i - t_{i-1}}) + \\sigma (W_{t_i} - W_{t_{i-1}}) } $$\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:(t_total)) {\n  s[,i+1] <- s[,i] * exp((r - 1/2 * sigma^2) * dt + sigma * dW[,i])\n}\n\nhead(s)\n#>      [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n#> [1,]  100  95.92209 114.16839 107.31161 105.75330 109.53595 111.60722\n#> [2,]  100  98.28292  97.04695  95.44803  97.24258 102.50728 109.62854\n#> [3,]  100 112.11600 119.98823 102.73710  98.70849  95.05115  90.09528\n#> [4,]  100 100.48258  96.33055  85.16909  78.05933  77.65918  73.14576\n#> [5,]  100 100.91830 102.56581  94.56668 101.01083 111.13033 109.93864\n#> [6,]  100 113.41388 123.22299 108.96314 108.79196 107.01479 126.30943\n```\n:::\n\nAnd that does work!\nBut can we avoid the loop?\nYES WE CAN!\n\n### MATH\n\nTo avoid the loop, we are going to manipulate a simple case, and then apply it generally.\nOne key element for this vectorization is that *brownian motion increments are independent*.\nLet's think about what actually happens from time 0-\\>1 and from 1-\\>2.\n\n$$ S_1 = S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) (t_1 - t_0) + \\sigma (W_1 - W_0)} $$\n\n$$ S_2 = S_1 \\times e^{(r - \\frac{1}{2} \\sigma^2) (t_2 - t_1) + \\sigma (W_2 - W_1)} $$\n\nIf we plug the equation for `S_1` into the equation for `S_2`...\n\n$$ S_2 = (S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) (t_1 - t_0) + \\sigma (W_1 - W_0)}) \\times e^{(r - \\frac{1}{2} \\sigma^2) (t_2 - t_1) + \\sigma (W_2 - W_1)} $$\n\nAnd then combine exponents...\n\n$$ S_2 = (S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) (t_1 - t_0 + t_2 - t_1) + \\sigma (W_1 - W_0 + W_2 - W_1)}) $$\n\nNotice that some of the `t` and `W` terms cancel:\n\n$$ S_2 = (S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) (t_2 - t_0) + \\sigma (W_2 - W_0)}) $$\n\nAnd by definition `t_0` and `W_0` are `0`:\n\n$$ S_2 = S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) t_2 + \\sigma W_2} $$\n\nThis is actually the form that was proposed as the solution to the geometric brownian motion stochastic differential equation:\n\n$$ S_t = S_0 \\times e^{(r - \\frac{1}{2} \\sigma^2) t + \\sigma W_t} $$\n\nIt looks like we can actually generate `S_2` without needing to know `S_1` at all.\nNotice that the exponent now contains `t_2` and `W_2`.\n`t_2` is known beforehand, but `W_2` seems like it would rely on `W_1` in a way that has to be recursively calculated.\nActually, if we think of `W_2` as a sum of brownian motion increments (I told you this would help):\n\n$$ W_2 = (W_2 - W_1) + (W_1 - W_0) = dW_2 + dW_1 $$\n\nthen `W_2` is just the *cumulative sum* of the increments, and, by definition, each increment is independent of the previous increment so we can generate them all before hand (we already did this when we created the `dW` matrix).\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rowwise cumulative sum of dW generates W1, W2, W3, ... for each simulation\nW  <- plyr::aaply(dW, 1, cumsum)\nhead(W)\n#>    \n#> X1            1          2          3           4          5          6\n#>   1 -0.16179538  0.5225740  0.2811560  0.22526661  0.3645603  0.4394974\n#>   2 -0.06644652 -0.1146010 -0.1782749 -0.10375422  0.1044858  0.3693483\n#>   3  0.44996033  0.7175510  0.1103186 -0.04507883 -0.1916658 -0.4001812\n#>   4  0.02035402 -0.1436573 -0.6251118 -0.96547795 -0.9841578 -1.2174893\n#>   5  0.03732215  0.1023001 -0.2146545  0.04534000  0.4212300  0.3804252\n#>   6  0.49509662  0.8218728  0.3410494  0.33635853  0.2732435  0.9247872\n```\n:::\n\nUnlike the recursive formula from before where `dt` was used, the time that we are currently at, `t`, is used instead so we will need that as well.\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_steps <- matrix(seq(from = dt, to = time_T, by = dt), \n                     nrow = N, ncol = t_total, byrow = TRUE)\nhead(time_steps)\n#>            [,1]      [,2] [,3]      [,4]      [,5] [,6]\n#> [1,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n#> [2,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n#> [3,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n#> [4,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n#> [5,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n#> [6,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n```\n:::\n\nNow it's a vectorized one-liner to calculate the stock price at each time!\n\n::: {.cell}\n\n```{.r .cell-code}\n# Stock price simulation\ns_t <- s_0 * exp((r - 1/2 * sigma^2) * time_steps + sigma * W)\n\n# Add the original stock price onto the front\ns_t <- cbind(s_0, s_t)\n\n# Add 0 as the column name for initial value (it's important I promise)\ncolnames(s_t)[1] <- \"0\"\n\nhead(s_t)\n#>     0         1         2         3         4         5         6\n#> 1 100  95.92209 114.16839 107.31161 105.75330 109.53595 111.60722\n#> 2 100  98.28292  97.04695  95.44803  97.24258 102.50728 109.62854\n#> 3 100 112.11600 119.98823 102.73710  98.70849  95.05115  90.09528\n#> 4 100 100.48258  96.33055  85.16909  78.05933  77.65918  73.14576\n#> 5 100 100.91830 102.56581  94.56668 101.01083 111.13033 109.93864\n#> 6 100 113.41388 123.22299 108.96314 108.79196 107.01479 126.30943\n```\n:::\n\nJust as a sanity check, this should have produced the same results as the for loop\n\n::: {.cell}\n\n```{.r .cell-code}\n# ignore the dimname attributes\nall.equal(s, s_t, check.attributes = FALSE)\n#> [1] TRUE\n```\n:::\n\n### Now what?\n\nThere are a number of interesting things we could do with these results.\nOne is to calculate the [fair price of a European Option](http://finance.bi.no/~bernt/gcc_prog/recipes/recipes/node12.html) on this stock.\nI think I'll save that for the next post.\n\nSomething else we might do is visualize the distribution of $S_T$, the stock price at the terminal (final) time.\nBecause the stock price is modeled as an exponential of a normal random variable (`W_t`), the stock price itself has a log-normal distribution.\nFor practicality, this means that it is right tailed and can't drop below 0 (good properties of a stock).\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# let's just take a moment and admire the fact that I can put LaTeX in ggplots\nlibrary(latex2exp) \n\ntibble::tibble(s_T = s_t[,6]) %>%\n  ggplot(mapping = aes(x=s_T)) +\n  geom_histogram(bins = 500) + \n  labs(x = TeX('S_T'), y = NULL, title = TeX('Log-normal Distribution of S_T') )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=792}\n:::\n:::\n\nWe could also look at the 6-step path of 100 of our simulations.\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(s_t) %>%\n  rownames_to_column(var = \"iteration\") %>%\n  gather(time_step, stock_price, -iteration) %>%\n  mutate(time_step = as.numeric(time_step),\n         iteration = as.factor(iteration)) %>%\n  filter(iteration %in% 1:100) %>%\n  \n  ggplot(aes(x = time_step, y = stock_price, group = iteration)) +\n  geom_line() +\n  labs(x = \"Time\", y = \"Stock Price\", title = \"100 Simulated Paths\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=792}\n:::\n:::\n\n### Conclusion + Extra Content\n\nIf I haven't bored you to tears yet, allow me to thank you for sticking around this long.\nI think these posts are useful because they force me to try and understand a concept a bit more than if I was just reading it from a book.\n\nAs you may have noted in the post above, I had to create a large matrix `time_steps` for R to perform the matrix addition I wanted correctly.\nI thought it would have been simple.\nIdeally I could create a `1x6` matrix of times, and add it to a `10000x6` matrix of the brownian motions and have the times matrix *broadcasted* to each row of the brownian motion matrix, adding element by element to each row.\nThis works in Python and Matlab, but R has a mind of it's own.\n\n::: {.cell}\n\n```{.r .cell-code}\n# First try with a vector\nx1 <- c(1,2)\nx1\n#> [1] 1 2\n\nx2 <- matrix(c(1,2,3,4), nrow = 2, ncol = 2, byrow = TRUE)\nx2\n#>      [,1] [,2]\n#> [1,]    1    2\n#> [2,]    3    4\n\n# I want to add c(1,2) to each row of x2\nx1 + x2\n#>      [,1] [,2]\n#> [1,]    2    3\n#> [2,]    5    6\n```\n:::\n\nThat's not right, it's adding 1 to the first column of `x2`, then 2 to the second column of `x2`.\nTo get what I want I could butcher it like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nt(x1+t(x2))\n#>      [,1] [,2]\n#> [1,]    2    4\n#> [2,]    4    6\n```\n:::\n\nIf `x1` was a matrix instead of a vector, then it gives a non-conformable array error.\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- matrix(x1, ncol = 2)\nx1\n#>      [,1] [,2]\n#> [1,]    1    2\n\nx1 + x2\n#> Error in x1 + x2: non-conformable arrays\n```\n:::\n\nSo R is super strict here.\nThat's fine and all, but with other languages able to do this, and with it being such a natural way of thinking about this type of addition, I decided to roll my own function that allows me to add matrices together that meet certain conditions by broadcasting one of them over the other.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Broadcast addition\n# One of the special % % operators\n`%+%` <- function(e1, e2) {\n  \n  stopifnot(is.matrix(e1))\n  stopifnot(is.matrix(e2))\n  \n  # e1 - e2 & 1 has more rows & equal cols\n  if(nrow(e1) >= nrow(e2) & ncol(e1) == ncol(e2)) {\n    case <- \"1\"\n    \n    # e1 - e2 & 2 has more rows & equal cols\n  } else if(nrow(e1) < nrow(e2) & ncol(e1) == ncol(e2)) {\n    case <- \"2\"\n    \n    # e1 - e2 & 1 has more cols & equal rows\n  } else if(ncol(e1) >= ncol(e2) & nrow(e1) == nrow(e2)) {\n    case <- \"3\"\n    \n    # e1 - e2 & 2 has more cols & equal rows\n  } else if(ncol(e1) < ncol(e2) & nrow(e1) == nrow(e2)) {\n    case <- \"4\"\n    \n    # Fail\n  } else {\n    stop(\"Incorrect dims\")\n  }\n  \n  switch(case,\n         \"1\" = t(apply(e1, 1, function(x) {x + e2})),\n         \"2\" = t(apply(e2, 1, function(x) {x + e1})),\n         \"3\" = t(apply(e1, 2, function(x) {x + e2})),\n         \"4\" = t(apply(e2, 2, function(x) {x + e1})))\n}\n```\n:::\n\nLet's see what this thing can do!\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 %+% x2\n#>      [,1] [,2]\n#> [1,]    2    4\n#> [2,]    4    6\n```\n:::\n\nNice!\nThat's what I want.\nOne thing to note is that order of operations don't work quite as you'd expect because of the precedence of the special `%+%` operator in relation to `+` and `*`, so you have to be really explicit.\n\n::: {.cell}\n\n```{.r .cell-code}\n# This tries to do addition first\nx1 * 2 %+% x2\n#> Error in 2 %+% x2: is.matrix(e1) is not TRUE\n\n# Explicit parenthesis\n(x1 * 2) %+% x2\n#>      [,1] [,2]\n#> [1,]    3    6\n#> [2,]    5    8\n```\n:::\n\nArmed with the ability to broadcast addition, let's redo the last step of the stock price simulation.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instead of a massive matrix, just create a 1x6\ntime_steps <- matrix(seq(from = dt, to = time_T, by = dt), nrow = 1, ncol = t_total)\ntime_steps\n#>            [,1]      [,2] [,3]      [,4]      [,5] [,6]\n#> [1,] 0.08333333 0.1666667 0.25 0.3333333 0.4166667  0.5\n\n# Remember that W is 10000x6\nhead(W)\n#>    \n#> X1            1          2          3           4          5          6\n#>   1 -0.16179538  0.5225740  0.2811560  0.22526661  0.3645603  0.4394974\n#>   2 -0.06644652 -0.1146010 -0.1782749 -0.10375422  0.1044858  0.3693483\n#>   3  0.44996033  0.7175510  0.1103186 -0.04507883 -0.1916658 -0.4001812\n#>   4  0.02035402 -0.1436573 -0.6251118 -0.96547795 -0.9841578 -1.2174893\n#>   5  0.03732215  0.1023001 -0.2146545  0.04534000  0.4212300  0.3804252\n#>   6  0.49509662  0.8218728  0.3410494  0.33635853  0.2732435  0.9247872\n\n# Add using broadcasted addition, making sure to be careful about parenthesis!\ns_t <- s_0 * exp(((r - 1/2 * sigma^2) * time_steps) %+% (sigma * W))\n\ns_t <- cbind(s_0, s_t, deparse.level = 0)\nhead(s_t)\n#>   [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n#> 1  100  95.92209 114.16839 107.31161 105.75330 109.53595 111.60722\n#> 2  100  98.28292  97.04695  95.44803  97.24258 102.50728 109.62854\n#> 3  100 112.11600 119.98823 102.73710  98.70849  95.05115  90.09528\n#> 4  100 100.48258  96.33055  85.16909  78.05933  77.65918  73.14576\n#> 5  100 100.91830 102.56581  94.56668 101.01083 111.13033 109.93864\n#> 6  100 113.41388 123.22299 108.96314 108.79196 107.01479 126.30943\n```\n:::\n\nSo much better!\nI have used this a few times in the past month or so.\nCredit to [Alex Hayes](https://twitter.com/alexpghayes) for teaching me a bit about why broadcasting is awesome.\nI created the base for `%+%` in response to his comments [here](https://gist.github.com/alexpghayes/286c2ff2eced494cf96763f19ff408ec).",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}