{
  "hash": "5a6c3a0ec6094cfb47a542562ada3591",
  "result": {
    "markdown": "---\ntitle: Debugging an R Package with C++\nauthor: Davis Vaughan\ndate: '2019-04-05'\nslug: debug-r-package-with-cpp\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## Introduction\n\nThis post is dedicated to teaching you how to debug an R package that has C++ code in it.\nI had no clue how to do this in a formal way, and honestly this post is for future me.\nThis post is long, because this stuff is finicky, and I wanted to document things as explictly as possible.\n\nThe method of debugging you will learn here has advantages and drawbacks:\n\n<ul style=\"list-style: none;\">\n\n<li>\n\n✅ It is great because you can jump right to places where R would generally crash and shut down, and instead have a chance to figure out why things broke.\n\n</li>\n\n<li>\n\n✅ You can print out any R variables at the C++ level.\n\n</li>\n\n<li>\n\n✅ You can step forward through your code, one line at a time, just like how you do from RStudio.\n\n</li>\n\n<li>\n\n✅ You can even step *up* into the function that called the one you are currently in, which is very valuable if you have a guess as to where something went wrong, and then want to backtrack to where the wrong result came from.\n\n</li>\n\n<li>\n\n✅ You can run arbitrary C++ code interactively while inside a function to help you interrogate objects.\n\n</li>\n\n<li>\n\n❌ It is painful to get going, and requires a decent amount of time investment.\n\n</li>\n\n<li>\n\n❌ Not every C++ expression works as you might expect when running it interactively.\nFor example, you can't easily use `std::cout`.\n\n</li>\n\n</ul>\n\nBecause this method is a pain to get going, my recommendation would be to start with printing out objects using some combination of:\n\n-   `Rcpp::Rcout << obj << std::endl` for Rcpp objects.\n-   `Rf_PrintValue()` for SEXP objects.\n-   `R_inspect()` for other details about SEXP objects (like attributes).\n\nIf you've tried that, and still can't seem to figure it out, it might be time for a true debugger.\n\n## OS\n\nI am using a MacOS running Mojave.\nI am also using R 3.5.1.\nI will be generally be using the Terminal to run R, rather than run it from RStudio.\n\nFor Windows users, you can probably use the Windows Command Prompt, but you might have to tweak your PATH variable, or explicitly specify the path to R to get it to run.\nSee [this Stack Overflow post](https://stackoverflow.com/questions/6940022/running-r-interactively-from-windows-command-prompt) for some potentially helpful info.\n(I'll pray for you).\n\n## gdb and lldb\n\nThere are two main C++ debuggers out there, as far as I know.\n`gdb` works alongside the `g++` compiler, and `lldb` works with the `clang++` compiler.\nThe one that you will use will depend on what compiler you use to compile the C/C++ code in your package with.\nIf you aren't sure what you are using, I'll show you an easy way to find out which one you have later on.\nI compile with `clang++`, so I'll be showing `lldb`.\n\nThere are a number of commands that will be useful.\nDon't worry about understanding them all now, this will serve as a nice reference for you later on:\n\n-   `run` (or `process launch`): Run R and drop me at the console.\n-   `next` (or `n`): Run the next line of C++ code.\n-   `step` (or `s`): Step *into* a function.\n-   `up`: Step *up* into the previous function call.\n-   `down`: Step *down* into the next function call.\n-   `finish`: Run the rest of the code.\n-   `frame variable`: Print the value of all of the variables in the current frame.\n-   `exit`: Exists lldb.\n-   `breakpoint set --name <function_name>`: Set a breakpoint that will be triggered whenever that function is called.\n-   `process continue`: Jump back into an already running R process you started with `run`.\n\nIt's also useful to know that when you are working at the R console in `lldb`, you can press `Ctrl + C` to exit the R process (without killing it) and jump back to the lldb console.\nPressing `CTRL + Z` at any point will kill lldb and the attached R process.\n\nIf you use `gdb`, there is a nice [command map](https://lldb.llvm.org/lldb-gdb.html) from gdb \\<-\\> lldb that will be useful to you as you follow along.\n\nThe general workflow is going to look like:\n\n-   Start the debugger with R attached\n-   Set a breakpoint\n-   `run` to start R\n-   Run some setup R code to activate breakpoints\n-   Trigger the error\n-   Debug!\n\n## Telling prompts apart\n\nIn my code blocks, I'll use the following conventions to tell apart the terminal, lldb, and R consoles:\n\n-   Terminal: `(term) <code>`\n-   lldb: `(lldb) <code>`\n-   R: `(R) <code>`\n\n## Example package\n\nEventually for these examples we will be using a mini package I created called `debugit`.\nIt lives on github [here](https://github.com/DavisVaughan/debugit).\nHop into RStudio and install it with devtools:\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"DavisVaughan/debugit\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDownloading GitHub repo DavisVaughan/debugit@master\n✔  checking for file ‘<stuff>’ ...\n─  preparing ‘debugit’:\n✔  checking DESCRIPTION meta-information ...\n─  cleaning src\n─  checking for LF line-endings in source and make files and shell scripts\n─  checking for empty or unneeded directories\n─  building ‘debugit_0.0.0.9000.tar.gz’\n   \n* installing *source* package ‘debugit’ ...\n** libs\nclang++  <stuff> -fPIC  -Wall -g -O2  -c RcppExports.cpp -o RcppExports.o\nclang++  <stuff> -fPIC  -Wall -g -O2  -c buggy.cpp -o buggy.o\nclang++  <stuff> -fPIC  -Wall -g -O2  -c stack.cpp -o stack.o\nclang++ -dynamiclib <stuff> -o debugit.so RcppExports.o buggy.o stack.o\ninstalling to /Library/Frameworks/R.framework/Versions/3.5/Resources/library/debugit/libs\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded\n* DONE (debugit)\nAdding ‘debugit_0.0.0.9000.tgz’ to the cache\n```\n:::\n\nBecause I don't hate you, I trimmed some of the output.\nDo you see the section starting with `* installing *source* package ‘debugit’ ...`?\nThere are two important things I want you to notice here:\n\n1)  `clang++` is at the front of those 4 lines. That's our compiler! So we should be using lldb.\n2)  These two \"flags\" `-g -O2`. These are important flags that can make you either very happy or very miserable as you try and debug. `-g` tells the compiler to \"compile with debug information\". `-O2` is the level of \"optimization\" that the compiler should use. `O0` is the lowest, and `O3` is the highest. With a lower level of optimization, more information is left lying around to help us debug. Higher levels of optimization can sometimes result in faster code. `O2` is what R defaults to when setting flags for your code. Unfortunately, this will come back to haunt us: *insert epic foreshadowing omen*.\n\nNow that we know what debugger we should be using, let's play around with attaching that debugger to R.\nWe will come back to the package after we are more comfortable with lldb.\n\n## Starting R with a debugger\n\nTo run R with a debugger, you'll need to run it from the command line.\nOpen up Terminal.\nFirst, just type `R`:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nR version 3.5.1 (2018-07-02) -- \"Feather Spray\"\nCopyright (C) 2018 The R Foundation for Statistical Computing\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n[master]> \n```\n:::\n\n[You can ignore the fact that my R prompt says `[master]>`. I've customized it using Gabor Csardi's [prompt](https://github.com/gaborcsardi/prompt) package! I promise it is the normal R prompt.]{.aside}\n\nThis started R from Terminal, and let's you work interactively from the R console.\nLet's close it back up.\nType `q()` then `n` and press Enter.\nYou should end up back at the terminal prompt.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) q()\nSave workspace image? [y/n/c]: n\n```\n:::\n\nTo start R with a debugger, run:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R -d lldb\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) target create \"/Library/Frameworks/R.framework/Resources/bin/exec/R\"\nCurrent executable set to '/Library/Frameworks/R.framework/Resources/bin/exec/R' (x86_64).\n(lldb) \n```\n:::\n\nWell that's different!\nIt looks like it dropped us into the lldb prompt, and is using R as the \"executable\".\nThis means that when we call `run`, it will run that executable, starting R.\nLet's do that.\nType `run` at the `lldb` prompt and hit enter.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) run\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nProcess 52472 launched: '/Library/Frameworks/R.framework/Resources/bin/exec/R' (x86_64)\n\nR version 3.5.1 (2018-07-02) -- \"Feather Spray\"\nCopyright (C) 2018 The R Foundation for Statistical Computing\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n[master]> \n```\n:::\n\n[If you get an error here rather than getting R to start, you might need clang4. Skip down to the `clang4 Required` section and then come back.]{.aside}\n\nSo this looks like what happened when we called `R`, but also has an extra line at the top about \"Process launched\".\nThis is now an R process that our debugger is \"attached\" to.\nRun the following R code at the R console:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) x <- 1 + 1\n```\n:::\n\nNow, rather than running `q()` to quit, let's exit the process without quitting and jump back into our debugger.\nPress `CTRL + C` and you should see:\n\n::: {.cell}\n\n```{.bash .cell-code}\nProcess 53060 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n    frame #0: 0x00007fff5af7ae82 libsystem_kernel.dylib`__select + 10\nlibsystem_kernel.dylib`__select:\n->  0x7fff5af7ae82 <+10>: jae    0x7fff5af7ae8c            ; <+20>\n    0x7fff5af7ae84 <+12>: movq   %rax, %rdi\n    0x7fff5af7ae87 <+15>: jmp    0x7fff5af73e31            ; cerror\n    0x7fff5af7ae8c <+20>: retq   \nTarget 0: (R) stopped.\n(lldb) \n```\n:::\n\nYou may or may not get all that unintelligible garbage about \"libsystem_kernel.dylib\\_\\_select:\".\nIt doesn't seem to hurt me thought so let's continue.\nThe main thing is that we got a `Target 0: (R) stopped.` and we are now back at the `(lldb)` prompt.\n\nIf you try and call `run` now you get this because you already have an R process running:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) run\n\nThere is a running process, kill it and restart?: [Y/n]\n```\n:::\n\nSo let's jump back into that R process with `process continue` and the lldb prompt:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) process continue\n\nProcess 53060 resuming\n```\n:::\n\nI get this message...and then it kind of hangs.\nI don't see the R console prompt.\nFor some reason, you have to help it along.\nPress Enter if nothing shows up.\n\n::: {.cell}\n\n```{.bash .cell-code}\nProcess 53060 resuming\n\n[master]> \n```\n:::\n\nThat's better.\nHere we can run R commands again in that same process we started in.\nTo prove that it is the same process, print `x`.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) x\n\n[1] 2\n```\n:::\n\nNow that you have a bit of the basics down, let's shut down and start over.\nPress `CTRL + C` and then run:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) exit\n```\n:::\n\nYou should be back at the Terminal prompt.\n\n## clang4\n\n*Only read this section if you couldn't get the debugger to start R. Otherwise skip on to the next section.*\n\nWhen trying to run the debugger with `R -d lldb` and then a call to `run`, at least on:\n\n-   R 3.5.1\n-   MacOS Mojave\n-   Compiling with clang\n\nI immediately hit something like:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) run \n\nProcess 74239 launched: \n'/Library/Frameworks/R.framework/Resources/bin/exec/R' (x86_64) \ndyld: Library not loaded: /usr/local/clang4/lib/libomp.dylib \n  Referenced from: /Library/Frameworks/R.framework/Resources/bin/exec/R \n  Reason: image not found \nProcess 74239 stopped \n* thread #1, stop reason = signal SIGABRT \n    frame #0: 0x000000010002c9ee dyld`__abort_with_payload + 10 \ndyld`__abort_with_payload: \n->  0x10002c9ee <+10>: jae    0x10002c9f8               ; <+20> \n    0x10002c9f0 <+12>: movq   %rax, %rdi \n    0x10002c9f3 <+15>: jmp    0x10002c300               ; cerror_nocancel \n    0x10002c9f8 <+20>: retq \n```\n:::\n\nI believe this was a bug that was fixed in December 2018.\nYou can read about that [here](http://r-sig-mac.29524.n8.nabble.com/R-SIG-Mac-CRAN-build-of-R-linking-to-usr-local-clang4-td228.html).\nIt's trying to tell you it can't find `/usr/local/clang4`, even though `clang6` is the recommended clang build nowadays.\nIf you hit this, ensure that you don't have `clang4` by opening a Terminal window and running:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) cd /usr/local\n(term) ls\n```\n:::\n\nIf you see clang6 there but not clang4, you need to get clang4 to continue.\nLuckily the research group at AT&T has you covered.\nGo to [this page](https://r.research.att.com/libs/) to see the libraries they provide.\nOne is clang4 (it's in alphabetical order).\nAt the bottom, they tell you how to install it.\nIf the version you see for clang 4.00 is the same as the one in the code below, you can open up a Terminal window and run this, otherwise, tweak it a bit as needed:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) curl -O http://r.research.att.com/libs/clang-4.0.0-darwin15.6-Release.tar.gz\n(term) sudo tar fvxz clang-4.0.0-darwin15.6-Release.tar.gz -C /\n```\n:::\n\nI *think* I got an error of some kind from this, but it didn't seem to affect anything in the end and ran fine.\nCheck `/usr/local` again and look for clang4.\n\nNote that it specifies `darwin15`, and their key specifies that this means you need MacOS El Capitan or higher for this to work.\n\n## The package\n\nNow that we know how to use the debugger, let's look at this package.\nHere is some real R code, run in RStudio and not at the command prompt:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(debugit)\nlibrary(rlang)\n\n# What are the names of the functions in the package?\nnames(pkg_env(\"debugit\"))\n#> [1] \"add_one\"   \"buggy_fun\"\n```\n:::\n\nThere are two functions here.\n`add_one()` takes a numeric input and supposedly adds 1 to it.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Or maybe not...\nadd_one(5)\n#> [1] 105\n```\n:::\n\n`buggy_fun()` is supposed to create an integer vector holding `0` and return it to you.\nInstead, it crashes R so you might not want to run it right away.\n\n## Debugging buggy_fun() - Round 1\n\nSo at this point, you've installed the package, and can use R with a debugger.\nNow it's time to learn how to debug a crashing R session.\nLet's demonstrate the problem.\nStart R from the command line:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R\n```\n:::\n\nNow run:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) debugit::buggy_fun()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n *** caught segfault ***\naddress 0x7f84fe68fd40, cause 'memory not mapped'\n\nTraceback:\n 1: buggy_fun_impl()\n 2: debugit::buggy_fun()\n\nPossible actions:\n1: abort (with core dump, if enabled)\n2: normal R exit\n3: exit R without saving workspace\n4: exit R saving workspace\n```\n:::\n\nR crashes!\nWe get a `\"memory not mapped\"` reason for the crash, and a traceback telling us that we called `debugit::buggy_fun()` and then the error happened in a function called `buggy_fun_impl()`.\nThis is the C++ function that is causing the issues (technically this is the R function that Rcpp exposed the C++ function of the same name as, but either way you think about it is fine).\nIt looks like this:\n\n::: {.cell}\n\n```{.c .cell-code}\nbool buggy_fun_impl() {\n\n  NumericVector x(1);\n\n  int n = INT_MAX;\n\n  x[n] = 0;\n\n  return true;\n}\n```\n:::\n\nIt creates `x`, an Rcpp numeric vector with length 1 (by default filled with the value `0`).\nBut then tries to assign `0` to a memory location at `INT_MAX` (a really big number).\nSince `x` doesn't \"own\" that memory, we crash.\nBut say we don't know all that...\n\nHow do we debug this?\nWell, we at least know we should be looking into `buggy_fun_impl()`, so lets start there.\nWhat we need to do is set a *breakpoint*.\nThis is a spot in the C++ code that we tell the debugger to stop at, so we can have a look around before everything implodes.\nYou can do that in a few ways with lldb.\n\n::: {.cell}\n\n```{.bash .cell-code}\n# breakpoint on a specific line\nbreakpoint set --file <file.cpp> --line <line-number>\n\n# breakpoint on a object/function name\nbreakpoint set --name <function_name>\n\n# breakpoint for any errors that are thrown\nbreakpoint set -E c++\n```\n:::\n\nThe last one is super useful when you have no idea where the error is happening, but usually you have a guess.\nLet's try setting it on the name `buggy_fun_impl`.\nBack in Terminal...\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R -d lldb\n\n(lldb) breakpoint set --name buggy_fun_impl\n\nBreakpoint 1: no locations (pending).\nWARNING:  Unable to resolve breakpoint to any actual locations.\n```\n:::\n\nSo we set the breakpoint, but it didn't actually find anything named `\"buggy_fun_impl\"`, so it set the breakpoint to `pending`.\nThis shouldn't be too surprising, we haven't started an R process yet (we haven't run `run`), and more importantly *we need to load the package that holds the buggy functions*.\nWe can confirm that the breakpoint exists with `breakpoint list`:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) breakpoint list\n\nCurrent breakpoints:\n1: name = 'buggy_fun_impl', locations = 0 (pending)\n```\n:::\n\nLet's start our R session and library the package.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) run\n\n(R) library(debugit)\n\n1 location added to breakpoint 1\n```\n:::\n\nImmediately as we loaded the package the breakpoint was set!\nGreat, now we just trigger the bug.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) buggy_fun()\n\nProcess 57494 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x00000001087c45e0 debugit.so`buggy_fun_impl()\ndebugit.so`buggy_fun_impl:\n->  0x1087c45e0 <+0>: pushq  %rbp\n    0x1087c45e1 <+1>: movq   %rsp, %rbp\n    0x1087c45e4 <+4>: pushq  %r15\n    0x1087c45e6 <+6>: pushq  %r14\nTarget 0: (R) stopped.\n```\n:::\n\nUh?\nOkay well it didn't crash.\nAnd it seems to be pointing us in the right direction:\n\n-   `stop reason = breakpoint 1.1` says that it stopped because it hit the breakpoint we requested\n-   `` debugit.so`buggy_fun_impl() `` is telling us it stopped at the function we are interested in\n\nBut I promised you line by line debugging power!\nWhat is this garbage?\nHere's the thing.\nI don't know why, but I can't seem to effectively debug packages that I installed using `install.packages()` or `install_github()`.\nThe information is just not there.\nInstead, you need to have the package locally on your computer (like you are a developer working on it), and you need to use `devtools::load_all()` rather than `library()` to load it.\n\nWhile this may seem frustrating, this is the probable state that you will be in when you are debugging.\nYou'll be the maintainer of the package, so you will have it locally and will be used to the `load_all()` workflow.\n\nTo get out of this, press `CTRL + Z` to kill `lldb`.\n\n## Debugging buggy_fun() - Round 2\n\nBy whatever means necessary, get the files for the `debugit` package locally on your computer.\nI think the easiest way is:\n\n::: {.cell}\n\n```{.r .cell-code}\n# you may have to set `protocol = \"https\"` as well depending on how you have\n# git set up\nusethis::create_from_github(\n  \"DavisVaughan/debugit\", \n  destdir = \"~/path/to/destination\"\n)\n```\n:::\n\nYou can also do a standard Fork + Clone github workflow.\nOr you can download the zip file if you are desparate.\nHere is the link to the [zip](https://github.com/DavisVaughan/debugit/archive/master.zip).\n\nI'm going to assume you now have it locally.\nJump back in Terminal, and change to the directory where you placed the package.\nIt is important that you start R from here!\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) cd ~/path/to/debugit\n```\n:::\n\nYou know you are in the right place if you see this:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) ls\n\nDESCRIPTION LICENSE     LICENSE.md  NAMESPACE   R       debugit.Rproj   man     src\n```\n:::\n\nStart the debugger, set a breakpoint, and jump back into R.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R -d lldb\n\n(lldb) breakpoint set --name buggy_fun_impl\n(lldb) run\n```\n:::\n\nNow, run a `devtools::load_all()`.\nBecause you are in the right working directory, it will automatically find the debugit package and install it.\nI see:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) devtools::load_all()\n\nLoading debugit\nRe-compiling debugit\n─  installing *source* package ‘debugit’ ...\n   ** libs\n   clang++  <stuff> -fPIC  -Wall -g -O2  -c RcppExports.cpp -o RcppExports.o\n   clang++  <stuff> -fPIC  -Wall -g -O2  -c buggy.cpp -o buggy.o\n   clang++  <stuff> -fPIC  -Wall -g -O2  -c stack.cpp -o stack.o\n   clang++ -dynamiclib <stuff> -o debugit.so RcppExports.o buggy.o stack.o\n   installing to /private/var/folders/41/qx_9ygp112nfysdfgxcssgwc0000gn/T/Rtmpr8QYTT/devtools_install_e1c251df2215/debugit/libs\n─  DONE (debugit)\n1 location added to breakpoint 1\n```\n:::\n\nIt recompiled the package, and then the breakpoint was set!\nNow trigger the bug.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) buggy_fun()\n\nProcess 57912 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x00000001085ecbe4 debugit.so`buggy_fun_impl() at buggy.cpp:7\n   4    // [[Rcpp::export()]]\n   5    bool buggy_fun_impl() {\n   6    \n-> 7      NumericVector x(1);\n   8    \n   9      int n = INT_MAX;\n   10   \nTarget 0: (R) stopped.\n(lldb)\n```\n:::\n\nWoah!\nNow it stopped right where we wanted it to.\nJust inside the `buggy_fun_impl()` function.\nWhat can we do with this?\n\nType `next` and hit enter to run the current line, this moves us to line 9:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) next\n\nProcess 57912 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step over\n    frame #0: 0x00000001085ecc03 debugit.so`buggy_fun_impl() at buggy.cpp:9\n   6    \n   7      NumericVector x(1);\n   8    \n-> 9      int n = INT_MAX;\n   10   \n   11     x[n] = 0;\n   12   \nTarget 0: (R) stopped.\n```\n:::\n\nView the available variables with `frame variable`.\nWe see `x`, which is a `NumericVector` with a more complicated structure, and `n` which is an `int`.\nLooks like `INT_MAX = 2147483647`.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) frame variable\n\n(Rcpp::NumericVector) x = {\n  Rcpp::PreserveStorage<Rcpp::Vector<14, Rcpp::PreserveStorage> > = (data = 0x00000001095c2b08)\n  cache = {\n    start = 0x00000001095c2b38\n  }\n}\n(int) n = 2147483647\n```\n:::\n\nWe can even run arbitrary C++ code with `expr`\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) expr 1 + 1\n\n(int) $2 = 2\n```\n:::\n\nIf you want to store the result, use the special syntax of `$var_name` rather than just `var_name`.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) expr int $var = 1 + 1\n(lldb) expr $var\n\n(int) $var = 2\n```\n:::\n\nHere's a neat trick, what if I want to print out the value of `x`?\nNormally I'd use `Rcpp::Rcout << x << std::endl`, but that doesn't work.\nWe have to call a function from the R API, `Rf_PrintValue()`, on the underlying SEXP that `x` stores.\nNormally I'd get at that with `SEXP(x)`, but that doesn't work either.\nWe *really* have to be creative.\nIf you look at what printed out for `x` earlier, you'll see a `data` member.\nThat's the SEXP, and we can call `Rf_PrintValue()` on that.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) expr Rf_PrintValue(x.data)\n\n[1] 0\n```\n:::\n\nNice!\nNow let's continue until we hit the bug:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) next\n\nProcess 57912 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x5095c2b30)\n    frame #0: 0x00000001085ecc2b debugit.so`buggy_fun_impl() at buggy.cpp:11\n   8    \n   9      int n = INT_MAX;\n   10   \n-> 11     x[n] = 0;\n   12   \n   13     return true;\n   14   }\nTarget 0: (R) stopped.\n```\n:::\n\nAh, looks like that did it.\nSee the `stop reason = EXC_BAD_ACCESS`?\nThat's our error saying we are \"badly accessing\" a location in memory.\nImportantly, *we now know exactly where the problem is*.\nAnd we have the power to print `x` and `n` and see that we are assigning to a location much larger than the size of `x`.\nSo, with that, we can fix our problem.\nPress `CTRL + Z` to exit.\n\n## Break on any errors\n\nJust for kicks and giggles, lets try setting the breakpoint a different way.\nThis way says to break any time we hit an error.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R -d lldb\n\n(lldb) breakpoint set -E c++\n(lldb) run\n\n(R) devtools::load_all()\n(R) buggy_fun()\n\nProcess 58089 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x5012cc530)\n    frame #0: 0x000000010a327c2b debugit.so`buggy_fun_impl() at buggy.cpp:11\n   8    \n   9      int n = INT_MAX;\n   10   \n-> 11     x[n] = 0;\n   12   \n   13     return true;\n   14   }\nTarget 0: (R) stopped.\n```\n:::\n\nThis immediately takes us to the problem line, where we can now look around like before using `expr` and `frame variable`.\n\n## Debugging add_one() - Round 1\n\nNow let's try a different problem.\n`add_one()` doesn't error, but clearly gives the wrong results.\nWe expect the result to be `6`.\n\n::: {.cell}\n\n```{.r .cell-code}\ndebugit::add_one(5)\n#> [1] 105\n```\n:::\n\nNow, generally I'd try and use some print statements to figure out WTF is happening here.\nThat's the quick way to do this and would probably work fine.\n\nBut let's say you have no idea what is happening, but you think something is going on in the underlying `add_one_impl()` C++ function that powers `add_one()`.\nThat looks like this:\n\n::: {.cell}\n\n```{.c .cell-code}\nNumericVector add_one_impl(NumericVector x) {\n\n  NumericVector y = get_one();\n\n  NumericVector result = x + y;\n\n  return result;\n}\n```\n:::\n\nLet's use the same tactic as before to set a breakpoint on `add_one_impl`.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R -d lldb\n\n(lldb) breakpoint set --name add_one_impl\n(lldb) run\n\n(R) devtools::load_all()\n(R) add_one(5)\n\ndebugit.so was compiled with optimization - stepping may behave oddly; variables may not be available.\nProcess 58425 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x00000001089d2693 debugit.so`add_one_impl(Rcpp::Vector<14, Rcpp::PreserveStorage>) [inlined] get_one() at stack.cpp:6 [opt]\n   3    \n   4    NumericVector get_one() {\n   5    \n-> 6      NumericVector one(1, 1.0);\n   7    \n   8      // Not 1!\n   9      one[0] = 100;\nTarget 0: (R) stopped.\n```\n:::\n\nAgh, what?\nThat's not right, somehow we ended up in the `get_one()` function instead.\nBut wait, what is that first line at the top:\n\n    debugit.so was compiled with optimization - stepping may behave oddly; variables may not be available.\n\nAh.\nRemember that bit at the beginning where I mentioned the \"flags\"?\nIt is coming back to haunt us.\nR compiled this code with `O2`, but that stripped out some of the debugging info, so our debugger stopped in the wrong place.\nWe need to recompile with `O0`.\nBut how do we do that?\nWe have to set `O0` as one of our `CXXFLAGS` in a `Makevars` file.\nThat sounds ridiculous but it isn't too bad thanks to `usethis.`\n\nOpen RStudio.\nRun:\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_makevars()\n```\n:::\n\nThis should open a file located at `~/.R/Makevars`.\nBe careful here!\nThis gets run whenever you install any packages with code that needs to be compiled.\nAdd the following lines:\n\n::: {.cell}\n\n```{.bash .cell-code}\nCXXFLAGS = -g -O0\n```\n:::\n\nSave and *make sure you add a new blank line after* the `CXXFLAGS` line.\nNow close out of RStudio again.\n\n## Debugging add_one() - Round 2\n\nLet's try this again:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(term) R -d lldb\n\n(lldb) breakpoint set --name add_one_impl\n(lldb) run\n```\n:::\n\nAt this point, if we run `devtools::load_all()` it actually won't do anything, because we already compiled the code once and none of the code actually changed.\nWe really need to force it to compile again by clearing out the old compiled code.\nYou can do that with:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) devtools::clean_dll()\n```\n:::\n\nIt will look like nothing happens, but if you run a `devtools::load_all()` it should compile:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) devtools::load_all()\n\nLoading debugit\nRe-compiling debugit\n─  installing *source* package ‘debugit’ ...\n   ** libs\n   clang++  <stuff> -g -O0 -c RcppExports.cpp -o RcppExports.o\n   clang++  <stuff> -g -O0 -c buggy.cpp -o buggy.o\n   clang++  <stuff> -g -O0 -c stack.cpp -o stack.o\n   clang++  <stuff> -o debugit.so RcppExports.o buggy.o stack.o\n   installing to <stuff>\n─  DONE (debugit)\n1 location added to breakpoint 1\n```\n:::\n\nLook!\nDo you see the `-g -O0` you set?\nIf so, you should be good to go.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) add_one(5)\n\nProcess 58576 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x000000010b865ebf debugit.so`add_one_impl(x=Rcpp::NumericVector @ 0x00007ffeefbfd198) at stack.cpp:17\n   14   // [[Rcpp::export()]]\n   15   NumericVector add_one_impl(NumericVector x) {\n   16   \n-> 17     NumericVector y = get_one();\n   18   \n   19     NumericVector result = x + y;\n   20   \nTarget 0: (R) stopped.\n```\n:::\n\nWoop!\nWe are now exactly where we wanted, and we don't get any of those annoying warnings about out package being compiled with optimization.\nRun `next` to have the `get_one()` line run.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) next\n\nProcess 58576 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step over\n    frame #0: 0x000000010b865ed7 debugit.so`add_one_impl(x=Rcpp::NumericVector @ 0x00007ffeefbfd198) at stack.cpp:19\n   16   \n   17     NumericVector y = get_one();\n   18   \n-> 19     NumericVector result = x + y;\n   20   \n   21     return result;\n   22   }\nTarget 0: (R) stopped.\n```\n:::\n\nWhat does `y` look like?\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) expr Rf_PrintValue(y.data)\n\n[1] 100\n```\n:::\n\nThat seems wrong.\nThis should just be `1`.\nWhat is happening in `get_one()`?\nLet's run `finish` to run the rest of the lines and try again:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) finish\n```\n:::\n\nRun `process continue` to dump us back into the R session so we can try again:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) process continue\n\nProcess 58576 resuming\n[1] 105\n[master]>\n```\n:::\n\nOh look, there's the result of that call we debugged.\nLet's go back into the debugger by calling it again.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(R) add_one(5)\n\nProcess 58576 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x000000010b865ebf debugit.so`add_one_impl(x=Rcpp::NumericVector @ 0x00007ffeefbfd198) at stack.cpp:17\n   14   // [[Rcpp::export()]]\n   15   NumericVector add_one_impl(NumericVector x) {\n   16   \n-> 17     NumericVector y = get_one();\n   18   \n   19     NumericVector result = x + y;\n   20   \nTarget 0: (R) stopped.\n```\n:::\n\nNow since we know `get_one()` seems to be the issue, we can *step into* the function with `step`:\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) step\n\nProcess 58576 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step in\n    frame #0: 0x000000010b865dcb debugit.so`get_one() at stack.cpp:6\n   3    \n   4    NumericVector get_one() {\n   5    \n-> 6      NumericVector one(1, 1.0);\n   7    \n   8      // Not 1!\n   9      one[0] = 100;\nTarget 0: (R) stopped.\n```\n:::\n\nOkay, we are inside `get_one()`.\nLet's run this line creating `one` and take a look at it.\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) next\n\nProcess 58576 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step over\n    frame #0: 0x000000010b865dff debugit.so`get_one() at stack.cpp:9\n   6      NumericVector one(1, 1.0);\n   7    \n   8      // Not 1!\n-> 9      one[0] = 100;\n   10   \n   11     return one;\n   12   }\nTarget 0: (R) stopped.\n```\n:::\n\nThings look okay now...\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) expr Rf_PrintValue(one.data)\n\n[1] 1\n```\n:::\n\nBut then you run the next line...\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) next\n\nProcess 58576 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step over\n    frame #0: 0x000000010b865e21 debugit.so`get_one() at stack.cpp:11\n   8      // Not 1!\n   9      one[0] = 100;\n   10   \n-> 11     return one;\n   12   }\n   13   \n   14   // [[Rcpp::export()]]\nTarget 0: (R) stopped.\n```\n:::\n\nAnd as I am sure you can guess by now, you see that `one` now holds `100` because of the assignment we did there on line 9!\n\n::: {.cell}\n\n```{.bash .cell-code}\n(lldb) expr Rf_PrintValue(one.data)\n\n[1] 100\n```\n:::\n\nNow *we know where the problem is*, so we can head back into our local copy of the package, fix the issue, and try again.\nAt this point, `CTRL + Z` to quit.\n\n*Don't forget to go comment out or delete that line in the `~/.R/Makevars` file!*\n\n## Wrapping up\n\nThis has been a *very* long winded post.\nBut hopefully it can serve as a reference that anyone can look back on and use to understand how to debug compiled code in an R package.\nI think the main points are:\n\n-   Use the workflow:\n    -   `R -d lldb`\n    -   Set a breakpoint\n    -   `run` to start R\n    -   `devtools::load_all()` to activate breakpoint\n    -   Trigger bug\n    -   Debug!\n-   Remember to use `-g -O0` when compiling.\n-   Remember to use `Rf_PrintValue()` on SEXP objects to get a pretty view of what the R object actually looks like, and `Rf_PrintValue(x.data)` to print Rcpp objects.\n\n## Resources\n\nHere are some extra resources I found really useful as I was figuring all this out:\n\n-   The [R Packages](http://r-pkgs.had.co.nz/src.html#src-debugging) section on debugging compiled code.\n-   Section [4.4.2 Inspecting R objects when debugging](https://colinfay.me/writing-r-extensions/debugging.html) from R Core's Writing R Extensions (bookdown-ified by Colin Fay) is quite useful. It is where I learned about `Rf_PrintValue()`. See also `R_inspect()`, and `Rf_PrintValue(x->attrib)` to view attributes of a SEXP.\n-   Kevin Ushey has a great [blog post](http://kevinushey.github.io/blog/2015/04/13/debugging-with-lldb/) with some more pointers on using `lldb` with Rcpp functions created on the fly.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}