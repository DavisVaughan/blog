{
  "hash": "7c8e9eed55d15a6c31a3974edf5b353d",
  "result": {
    "markdown": "---\ntitle: almanac 0.1.0\nauthor: Davis Vaughan\ndate: '2020-05-27'\nslug: almanac-0-1-0\neditor_options: \n  chunk_output_type: console\n---\n\nI'm very excited to announce that the first release of [almanac](https://davisvaughan.github.io/almanac/index.html) has made its way to CRAN!\nalmanac is a package for working with *recurring events*.\nThese typically include dates that occur on some kind of recurring basis, like weekends or holidays.\nAs you'll soon see, one of the most powerful features of almanac is the ability to build up a set of these recurring events, like a company's holiday calendar, so that you can then shift a vector of dates by, say, 5 business days, skipping over any weekends or holidays that might be specific to your company.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(almanac)\n```\n:::\n\n### Recurrence Rules\n\nTo start working with recurring events, we'll need a way to define when those events happen.\nThis is known as a *recurrence rule*, and is most easily built up using a chain of pipes like this:\n\n::: {.cell}\n\n```{.r .cell-code}\non_thursday <- weekly() %>%\n  recur_on_wday(\"Thursday\")\n```\n:::\n\nThis rule defines Thursdays as \"events\".\nA Thursday comes around on a `weekly()` basis, but you can also create rules for `daily()`, `monthly()`, and `yearly()`.\nThe call to `recur_on_wday()` further isolates exactly when the event occurs in the week.\nI call these *recurrence conditions*, and almanac comes with a whole family of them.\nAll recurrence condition functions start with `recur_*()`.\n\nYou can generate the events that fall between two dates with `alma_search()`.\nFor example, here are all of the Thursdays in January 2019.\n\n::: {.cell}\n\n```{.r .cell-code}\nalma_search(\"2019-01-01\", \"2019-01-31\", on_thursday)\n#> [1] \"2019-01-03\" \"2019-01-10\" \"2019-01-17\" \"2019-01-24\" \"2019-01-31\"\n```\n:::\n\nA more common use case is to create a rule that defines when a particular holiday happens.\nFor example, Thanksgiving happens on the 4th Thursday in November.\nHere's a recurrence rule for Thanksgiving:\n\n::: {.cell}\n\n```{.r .cell-code}\non_thanksgiving <- yearly() %>%\n  recur_on_wday(\"Thursday\", nth = 4) %>%\n  recur_on_ymonth(\"November\")\n\non_thanksgiving\n#> <rrule[yearly / 1900-01-01 / 2100-01-01]>\n#> - ymonth: Nov\n#> - wday: Thu[4]\n```\n:::\n\nSearch for all Thanksgivings between 2010-2015:\n\n::: {.cell}\n\n```{.r .cell-code}\nalma_search(\"2010-01-01\", \"2015-12-31\", on_thanksgiving)\n#> [1] \"2010-11-25\" \"2011-11-24\" \"2012-11-22\" \"2013-11-28\" \"2014-11-27\"\n#> [6] \"2015-11-26\"\n```\n:::\n\nYou can also check if a particular date is contained in a rule's *event set* (the set of dates that that rule considers events) using `alma_in()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- as.Date(c(\"2015-11-26\", \"2015-11-27\"))\n\nalma_in(x, on_thanksgiving)\n#> [1]  TRUE FALSE\n```\n:::\n\n### Recurrence Bundles\n\nRecurrence rules just scratch the surface of what almanac can do.\nThey are powerful on their own, but they can't answer every question.\nAn easy way to see their limitations is to try and construct a rule that defines Christmas *or* Thanksgiving as events.\nYou can easily create rules for the individual holidays, but it would be impossible to create 1 rule that captures both.\nThis is where *recurrence bundles* come in.\nThey allow you to combine the event sets of multiple rules together in a variety of ways using set-based logic.\nHere's a recurrence bundle for Christmas or Thanksgiving:\n\n::: {.cell}\n\n```{.r .cell-code}\non_christmas <- yearly() %>%\n  recur_on_mday(25) %>%\n  recur_on_ymonth(\"December\")\n\nhldy_bundle <- runion() %>%\n  add_rschedule(on_christmas) %>%\n  add_rschedule(on_thanksgiving)\n```\n:::\n\n`runion()` initializes a new recurrence bundle that takes the *union* of the event sets of each recurrence rule you pass it.\nalmanac also comes with `rintersect()` and `rsetdiff()` bundle types.\nBelow, we'll use `alma_next()` to generate the next events after these particular dates.\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- as.Date(c(\"2019-11-01\", \"2019-12-01\"))\n\n# The first event after 2019-11-01 is Thanksgiving\n# The first event after 2019-12-01 is Christmas\nalma_next(dates, hldy_bundle)\n#> [1] \"2019-11-28\" \"2019-12-25\"\n```\n:::\n\nYou can even add recurrence bundles to other recurrence bundles to make infinitely complex rules.\nFor example, maybe we want all Thanksgiving and Christmas holidays, *except* for Thanksgiving dates that occur on the 26th of the month and Christmas dates that occur on a Wednesday.\n\nFirst we can create a bundle for the dates we want to exclude:\n\n::: {.cell}\n\n```{.r .cell-code}\non_26th <- monthly() %>%\n  recur_on_mday(26)\n\non_wednesday <- weekly() %>%\n  recur_on_wday(\"Wed\")\n\nexclusion_bundle <- runion() %>%\n  add_rschedule(on_26th) %>%\n  add_rschedule(on_wednesday)\n```\n:::\n\nThen we can create a setdiff bundle to remove them from the holiday event set:\n\n::: {.cell}\n\n```{.r .cell-code}\nhldy_bundle_with_exclusions <- rsetdiff() %>%\n  add_rschedule(hldy_bundle) %>%\n  add_rschedule(exclusion_bundle)\n```\n:::\n\n[The order matters with this `rsetdiff()` bundle creation. If the order was flipped, it would be all Wednesdays and 26ths of the month except for those on Christmas and Thanksgiving.]{.aside}\n\nTo validate that, let's generate some events before and after applying the exclusion criteria and check the results:\n\n::: {.cell}\n\n```{.r .cell-code}\nfrom <- as.Date(\"2010-01-01\")\nto <- as.Date(\"2015-12-31\")\n\nhldys_2010_2015 <- alma_search(from, to, hldy_bundle)\nhldys_exclude_2010_2015 <- alma_search(from, to, hldy_bundle_with_exclusions)\n\n# Find holidays that don't exist in the exclusion bundle\nexists <- hldys_2010_2015 %in% hldys_exclude_2010_2015\nnot_exists <- !exists\n\n# 2013-12-25 - A Wednesday\n# 2015-11-26 - On the 26th\nhldys_2010_2015[not_exists]\n#> [1] \"2013-12-25\" \"2015-11-26\"\n```\n:::\n\n### Adjusters\n\nThere are other things that you can do with these recurrence rules and bundles beyond just generating dates in their event sets.\nOne powerful idea is to take an existing vector of dates and *adjust* it in the places where it lands on an event defined by a recurrence bundle.\n\nalmanac comes with a number of adjusters that specify what kind of adjustment to make when this happens.\nFor example, `adj_following()` will adjust to the next non-event date, and `adj_preceding()` will adjust to the preceding one.\n\n::: {.cell}\n\n```{.r .cell-code}\nchristmas <- \"2019-12-25\"\n\nadj_following(christmas, on_christmas)\n#> [1] \"2019-12-26\"\n\nadj_preceding(christmas, on_christmas)\n#> [1] \"2019-12-24\"\n```\n:::\n\n### Adjusted rules\n\nThese adjusters are critical low-level components that power more interesting aspects of almanac.\nOne of those is an *adjusted rule*.\n\nTo motivate it, imagine your company deems Christmas to be a holiday.\nWhenever Christmas rolls around on the 25th of December, you get that day off.\nBut what happens when Christmas falls on a Saturday?\nWhat about Sunday?\nMost corporations will *observe* a holiday that falls on the weekend on the nearest working day instead of on the weekend date that it actually occurred on.\n\nIn almanac, it seems like this would pose a problem.\nYou can create rules for Christmas and for weekends, but a recurrence bundle like runion, rintersect, or rsetdiff can only perform some kind of set operation on those individual rules.\nWhat you really need is a way to say: recur on the dates defined by this rule, unless it intersects with this second rule.\nIn those cases, apply an adjustment to the intersected dates to create valid dates.\nThis is the job of the adjusted rule.\n\n::: {.cell}\n\n```{.r .cell-code}\n# A rule for weekends\non_weekends <- weekly() %>%\n  recur_on_weekends()\n\n# Create an adjusted rule that normally occurs on Christmas,\n# unless Christmas is on a weekend, in which case it rolls to \n# the nearest non-event date (so this rolls Saturday Christmas\n# dates to Friday, and Sunday dates to Monday).\non_adjusted_christmas <- radjusted(\n  rschedule = on_christmas,\n  adjust_on = on_weekends,\n  adjustment = adj_nearest\n)\n\non_adjusted_christmas\n#> <radjusted>\n#> \n#> Adjust:\n#> <rrule[yearly / 1900-01-01 / 2100-01-01]>\n#> - ymonth: Dec\n#> - mday: 25\n#> \n#> Adjust on:\n#> <rrule[weekly / 1900-01-01 / 2100-01-01]>\n#> - wday: Sat, Sun\n```\n:::\n\nThis is just another type of recurrence object, so it can be used with all of the other `alma_*()` functions we have seen so far.\nFor example, we can confirm that Christmas dates that fall on the weekend are adjusted appropriately by searching for a few of them.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note 2004-12-24, which was rolled back from 2004-12-25, a Saturday.\n# Note 2005-12-26, which was rolled forward from 2005-12-25, a Sunday.\nalma_search(\"2002-01-01\", \"2006-01-01\", on_adjusted_christmas)\n#> [1] \"2002-12-25\" \"2003-12-25\" \"2004-12-24\" \"2005-12-26\"\n```\n:::\n\n### Stepping\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate, warn.conflicts = FALSE)\n```\n:::\n\n`alma_step()` allows you to take an existing vector of dates and shift it by a number of days, \"stepping over\" any events in the event set defined by a recurrence object.\nThis is generally useful for shifting by \"N business days\", where the logic for a business day is encapsulated in the rule.\n\nYou can think of `alma_step()` as a way to replace lubridate's `x + days(5)` with `x + business_days(5)` where `business_days()` is specific to your company's holiday calendar.\n\nIn the following example, we shift a Thursday and Friday by 2 working days.\nNotice that Thursday is shifted to Monday and Friday is shifted forward to Tuesday.\n\n::: {.cell}\n\n```{.r .cell-code}\n# A Thursday / Friday pair\nx <- as.Date(c(\"2019-12-19\", \"2019-12-20\"))\n\n# Shift by 2 working days, stepping over weekends\nstep <- alma_step(x, n = 2, rschedule = on_weekends)\n\ndata.frame(\n  x = x,\n  x_wday = wday(x, label = TRUE),\n  step = step,\n  step_wday = wday(step, label = TRUE)\n)\n#>            x x_wday       step step_wday\n#> 1 2019-12-19    Thu 2019-12-23       Mon\n#> 2 2019-12-20    Fri 2019-12-24       Tue\n```\n:::\n\nInternally, `n` is applied 1 day at a time.\n`adj_following()` is called after each 1 day shift if `n` is positive, otherwise `adj_preceding()` is called.\n\nTo break this down, we'll analyze that Friday.\n\n-   Start on `2019-12-20`, a Friday.\n-   Step forward 1 day, to `2019-12-21`, a Saturday.\n-   Apply `adj_following()`, landing us on Monday, `2019-12-23`.\n-   Step forward 1 day, to `2019-12-24`, a Tuesday.\n-   Apply `adj_following()`, but nothing needs to be done.\n\n### Steppers\n\n`alma_step()` is nice, but it would be really nice to have something like lubridate's `x + days(5)` syntax, but relative to a recurrence rule.\nDue to some issues with how R's S3 dispatch system works with `+`, this isn't exactly replicable with almanac, but you can get close.\n[lubridate uses R's S4 object oriented system to get it to work, but I don't want to go there]{.aside}\n\nFirst off, you need an object the holds information about how to shift relative to a recurrence rule.\nYou can create one of these with `stepper()`.\nThe only thing you give `stepper()` is the rule to step relative to.\nIt returns a function of 1 argument, `n`, which you'll call with the desired number of days to shift.\nThe resulting object can be added to or subtracted from your vector of dates.\nIt sounds a little complicated, but hopefully things will clear up with an example.\nLet's reproduce the last example from the previous section:\n\n::: {.cell}\n\n```{.r .cell-code}\nworking_days <- stepper(on_weekends)\n\nx %s+% working_days(2)\n#> [1] \"2019-12-23\" \"2019-12-24\"\n```\n:::\n\nNotice the usage of `%s+%`.\nThis replaces `+`, and allows you to step forward.\nThere is also a `%s-%` for stepping backwards.\n\nThe nice thing about `working_days()` is that you can continue to use it on other date vectors.\n\n::: {.cell}\n\n```{.r .cell-code}\n# A Wednesday\nwednesday <- as.Date(\"2019-12-18\")\n\n# Returns Thursday, Friday, Monday\nwednesday %s+% working_days(1:3)\n#> [1] \"2019-12-19\" \"2019-12-20\" \"2019-12-23\"\n```\n:::\n\n### Vacation\n\nI don't really expect you to build all of your holidays and calendars from scratch.\nalmanac holds the building blocks so that this is all possible, but an add-on package, [vacation](https://github.com/DavisVaughan/vacation), will eventually hold pre-generated holidays and calendars (like the US Federal calendar) with more bells and whistles.\n\n### Learning More\n\nTo learn more about almanac, visit [the pkgdown site](https://davisvaughan.github.io/almanac/).\nIn particular, head over to the [Introduction to almanac](https://davisvaughan.github.io/almanac/articles/almanac.html) vignette.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}