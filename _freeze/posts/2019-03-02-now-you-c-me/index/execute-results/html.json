{
  "hash": "c831d67e072173deebd4ac04a7059801",
  "result": {
    "markdown": "---\ntitle: Now You C Me\nauthor: Davis Vaughan\ndate: '2019-03-02'\n---\n\n\n\n### Introduction\n\nThis post is designed to help you get up and running with an R package that uses C code, teaching the absolute minimum required to get going.\nOver the past few days, I learned a lot about working with packages that call C.\nIt's not quite as pleasant as working with C++ and [Rcpp](https://github.com/RcppCore/Rcpp), but as you start to figure it out, it really feels like a superpower.\n[Superpower or not, as [Jim Hester says](https://twitter.com/jimhester_/status/1102270352057614338), if you have the choice it is much easier to use Rcpp, and my advice would also be to start there. I created this guide because I was contributing to a project that used C, and was frustrated by the lack of resources for beginners.]{.aside}\n\nThat said, it's a steep learning curve.\nYes, [Writing R Extensions](https://cran.r-project.org/doc/manuals/r-release/R-exts.html) has much of what you need to know, but I'm not big on the whole [RTFM](https://en.wikipedia.org/wiki/RTFM) idea, and I think posts that actually get you up and running so you can start exploring on your own are valuable.\n\n### Package\n\nSo let's go.\nI'm going to create a C function that takes one numeric argument of length 1, and adds 1 to it.\nThen, I'll show how to call it from R so users of the package can actually interface with it.\nExciting.\n\nWe need the structure for a package, so let's use some [`usethis`](https://github.com/r-lib/usethis) helpers to get started.\nWe'll call the package `addr`, and you should replace `path` with the path to the location you want the package created at.\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_package(path = \"~/path/to/addr\")\n```\n:::\n\nIf you work with RStudio, this should open a new RStudio instance with the `addr` package opened up.\nSwitch over to that.\n\n### Optional git\n\nIf you are so inclined and have everything hooked up (you've used git before on your computer), you can set up git and GitHub for this repo.\nI'll do it so you can see the final product, along with all of the commits along the way.\nYou can find my end result [here](https://github.com/DavisVaughan/addr).\n\n::: {.cell}\n\n```{.r .cell-code}\n# This will restart RStudio\nusethis::use_git()\n\n# Then call this to use github\n# for this package\nusethis::use_github()\n```\n:::\n\n### roxygen2\n\nSome of the `usethis` functions we are going to call require `roxygen2` to be used for creating documentation (and it makes our lives a heck of a lot easier).\nLet's set that up next.\nThe easiest way is to just call:\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::document()\n```\n:::\n\nAlternatively, on a Mac I can call CMD+Shift+D.\nThis should just add some information about roxygen2 to the `DESCRIPTION` file.\n\nThe other thing we will want to do is create a \"package doc\" `.R` file.\nOther `usethis` functions called later will use this file to store useful information automatically.\nBasically, this is just a `.R` file named `addr-package.R`.\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_package_doc()\n```\n:::\n\nThe contents of this look like:\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @keywords internal\n\"_PACKAGE\"\n\n# The following block is used by usethis to automatically manage\n# roxygen namespace tags. Modify with care!\n## usethis namespace: start\n## usethis namespace: end\nNULL\n```\n:::\n\nThe `usethis` information is going to be inserted between the `usethis namespace: start` and `usethis namespace: end` lines as we go along.\n\n### Can you C?\n\nLet's work on our first C function.\nAssuming you are in RStudio and in the current `addr` project, let's create our first C file.\nThere's a `usethis` helper for that too.\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_c(\"add\")\n```\n:::\n\nWow.\nThat did a lot more than just create a C file.\nI get something like this:\n\n::: {.cell}\n\n```{.r .cell-code}\n#> ✔ Creating 'src/'\n#> ✔ Adding '*.o', '*.so', '*.dll' to 'src/.gitignore'\n#> ✔ Adding '@useDynLib addr, .registration = TRUE' to 'R/addr-package.R'\n#> ● Run `devtools::document()` to update 'NAMESPACE'\n#> ✔ Writing 'src/add.c'\n#> ● Modify 'src/add.c'\n```\n:::\n\nSo what happened here?\n\n1)  A new directory was created, `src/`.\n    This is where all of your C files go.\n\n2)  Multiple types of files were added to a `.gitignore` in `src/`.\n    This is very helpful, as these 3 types of files, `.o`, `.so` and `.dll` are ones that would be created by our package when the C code is compiled, or \"built\" if you are familiar with R packages.\n    In the same way that we wouldn't commit a built R package to github, we don't commit these files either.\n\n3)  Some information was added to `addr-package.R`, and we get a suggestion to `document()`.\n\n4)  A new file, `src/add.c` was added, and then it opened in RStudio.\n    Great!\n    We will work on this file in a moment.\n\nWhat's this information that got added to `addr-package.R`?\nIf we open up `addr-package.R` right now, we will see:\n\n::: {.cell}\n\n```{.r .cell-code}\n## usethis namespace: start\n#' @useDynLib addr, .registration = TRUE\n## usethis namespace: end\nNULL\n```\n:::\n\nThe second line here is a roxygen comment added by `use_c()`, and it is an important one!\nBasically, it is the way we eventually tell R that we should be looking for any C routines (functions) that we have \"registered\" (i.e. exposed to the R side), so we can actually call them from R.\n\nReally, this information needs to be in the package NAMESPACE file, which contains the information on what functions are imported to and exported from your package, along with information about external code like this.\nThat's why a suggestion to document popped up, as roxygen2 will take care of that for you:\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::document()\n```\n:::\n\n[If you got an error while documenting that looked like `getDLLRegisteredRoutines.DLLInfo()`, don't be alarmed. We just don't have any C code for it to load.]{.aside}\n\nCheck out the `NAMESPACE` file and you should see:\n\n::: {.cell}\n\n```{.r .cell-code}\nuseDynLib(addr, .registration = TRUE)\n```\n:::\n\n### addr_add_one()\n\nNow we are ready to work on our C function.\nOpen up that `add.c` file if it isn't open already.\nYou should see this at the top:\n\n::: {.cell}\n\n```{.c .cell-code}\n#define R_NO_REMAP\n#include <R.h>\n#include <Rinternals.h>\n```\n:::\n\nThe second two `#include` lines give us access to the C-level R API. If you aren't familiar with includes or header files, for now think of them as calling `library()` on a package to get access to its functions for your own use.\n\nThe first line, `#define R_NO_REMAP`, purposefully comes before the other two, and prevents a \"re-mapping\" of the API functions from a standardized name of `Rf_<fn>` to just `<fn>`.\nI think it's pretty good practice to prevent this remapping, as it makes it clear to us what functions are from the R API (and it works really well for finding new functions with auto-complete!).\n\nOKAY, now let's write some C code.\nGo ahead and add these lines to the file:\n\n::: {.cell}\n\n```{.c .cell-code}\n#define R_NO_REMAP\n#include <R.h>\n#include <Rinternals.h>\n\nSEXP addr_add_one(SEXP a) {\n\n  SEXP out = PROTECT(Rf_allocVector(REALSXP, 1));\n\n  REAL(out)[0] = Rf_asReal(a) + 1;\n\n  UNPROTECT(1);\n\n  return out;\n}\n```\n:::\n\n...okay.\nThis looks foreign.\nSo many questions, I know, I had them too.\nI'll tackle as many as I can think of.\nFirst, a broad overview of what this code does:\n\n-   Take in a single argument, `a`.\n-   Create an object that we will assign the result to, `out`. This is a numeric vector of length 1. We also protect that object from the garbage collector.\n-   Add 1 to `a` and assign it to `out`.\n-   Unprotect our result, `out`, as we are about to return it.\n-   Return the result.\n\n#### What is a SEXP?\n\nGood question.\nIt's called an S-Expression, don't ask me how to pronounce the shorthand notation, and I think it originated in the functional language, Lisp.\n\nJust think of a SEXP as a container that is able to represent *any* kind of R object, but at the C level.\nThis means that an R list can be a SEXP, so can a matrix, so can a single logical value.\n\n#### Why are there so many explicit types?\n\nMeaning, why is the argument `SEXP a` and not just `a`?\nWhy is the return value, `out`, created as `SEXP out =` not just `out =`?\n\nC is a statically typed language, unlike R.\nWhereas in R we have the flexibility to create variables of any type without specifying the type in advance, in C we have to specify the type of every single variable ahead of time.\nThis comes with the benefit of speed, and is one of the reasons C is so much faster than R.\n\n#### Allocation and protection\n\nIn C, creating new R objects is a bit more complicated than what you'd do at the R level.\nWe know that we are going to take in a numeric vector of length 1, `a`, and we want to add 1 to it and return that result, which is also a numeric vector of length 1.\nSo we need a place to put that result.\n\nTo do so, we have to create a new numeric vector of length 1 at the C level.\nThe easiest way to do this is using a function from the R API, `Rf_allocVector()`.\nIt takes in two arguments, a `SEXPTYPE` (the type of the SEXP to make) and a `R_xlen_t` (the length of the SEXP) and returns a SEXP of the type and length requested.\n\nThere are 7 `SEXPTYPE`s you can use, and you can find information about them at Hadley's [R Internals](https://github.com/hadley/r-internals/blob/master/vectors.md) documentation repo.\nWe used the type for a \"real\" (numeric) vector, `REALSXP`.\nWe also specified the length to be 1.\n\nGreat, so we used `Rf_allocVector(REALSXP, 1)` to create a numeric vector of length 1.\nAll good?\nNot quite.\nWe also have to *protect* that numeric vector.\nFrom what?\nWell, if we don't protect it by wrapping it in `PROTECT()` immediately, then when R's garbage collector runs (which I think of as happening randomly), then that object gets cleaned up and removed 😢.\nIf not managed correctly, this can cause great heartache.\n\nAs if it wasn't difficult enough, we also have to manage *unprotecting* all of these objects.\nWe do that here by calling `UNPROTECT(1)` at the end of the function, right before we return our result.\n`UNPROTECT()` takes an integer value of the number of things to unprotect, so if you had created 3 new objects, you could call `UNPROTECT(3)` instead.\n[We don't have to protect and unprotect the *arguments* to the function, as R knows to protect these automatically.]{.aside}\n\n#### Autocomplete ❤️\n\nYou might be wondering, \"How did he know about `Rf_allocVector()`?\" Or, \"How do I find more of these neat C level API functions?\" Great question!\nLuckily, RStudio's autocomplete has your back.\nBy typing `Rf_` and pressing tab, we get the following pop up that we can scroll through.\n\n![](img/autocomplete.png)\n\nUsing this, we can find new functions to ~~research~~ google and learn about.\n\nSimilarly, how did I know what type `Rf_allocVector()` took and returned?\nWell...\n\n![](img/types-alloc.png)\n\nThe popup we get from RStudio tells us not only the name of the C function, but also the types of the arguments and return value!\n\nIn a moment, we will use `Rf_asReal()`.\n\n![](img/types.png)\n\n#### Addition\n\nOkay, so about the actual addition line...\n\n::: {.cell}\n\n```{.c .cell-code}\nREAL(out)[0] = Rf_asReal(a) + 1;\n```\n:::\n\nThat seems like a lot of work to add 1.\n\n`Rf_asReal()` takes a SEXP, and returns a single `double` value corresponding to the first element in the SEXP.\nA `double` is the C type that is somewhat equivalent to an R numeric.\nSo this converts our numeric vector of length 1, `a`, into an object that can be manipulated at the C level with C operations like addition.\n\nNext, we add 1 to that `double` that `Rf_asReal()` gives us.\nAfter that, we have to put it somewhere.\nIf you thought we could just do `out = Rf_asReal(a) + 1`, well, haven't you learned by now that it isn't ever that simple?\n\n`out` is a SEXP, and we can't assign a `double` straight to a SEXP.\nWhat we actually need is a way to access the `double` *underlying* the `out` SEXP we created.\nThat is what `REAL(out)` gets us.\nTechnically, it gives us a `double*` (a double pointer) that points to the actual double array that `out` abstracts away into an R numeric vector.\nJargon aside, it gives us something that we can kind of treat like an R vector, where we can index into it with `[]` and assign values to those slots.\n\nOne more note is that C is 0-index based, while R is 1-index based, so rather than doing `REAL(out)[1]` to access the first position, we really do `REAL(out)[0]`.\n\nAlright, so `REAL(out)` gave us access to the `double*`, and `REAL(out)[0]` gave us access to the actual `double` at the 1st position in the vector.\nThis is a `double`, so we can assign our result to this.\n\n#### Return\n\nFinally, after calling `UNPROTECT(1)` as described above, we return `out` with `return out`.\nUnlike R, you actually have to specify the `return` in C (it's generally optional in R).\n\nNote that in the function signature, we specified `SEXP addr_add_one(...)`.\nThe `SEXP` at the beginning there was our way of telling C that we are going to be returning a SEXP object.\n\n### Registration\n\n*Update) I have since learned that this registration section can be generated automatically! I highly recommend still reading this post in order to understand what the registration piece does, but check out the Automatic Registration section at the end of the post to learn how to do it automatically.* [Thanks, [Hadley & Jim](https://twitter.com/hadleywickham/status/1102200089773256704) and [Metin](https://twitter.com/strboul/status/1102207504405139456).]{.aside}\n\nGreat, so we have a C function that can add 1.\nCan we call this from R yet?\nAlmost, but still no.\nIf you run a `devtools::load_all()`, then you *should* see the code compile.\nFor me that looks like this, but I've manually trimmed it so you aren't overloaded with output:\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Loading addr\n#> Re-compiling addr\n#> ─  installing *source* package ‘addr’ ...\n#>    ** libs\n#>    clang <trimmed>  -c add.c -o add.o\n#>    clang -dynamiclib <trimmed> -o addr.so add.o\n#>    installing to /private/var/<trimmed>/addr/libs\n#> ─  DONE (addr)\n```\n:::\n\nThis is telling us that the:\n\n-   `add.c` was compiled into an \"object\" file, `add.o`.\n-   That one object file was used to make an `addr.so` \"shared object\". You can maybe think of this kind of like a \"built\" R package.\n\nNevertheless, if you try and do `addr::` after running `load_all()`, you will be disappointed, and you won't see `addr_add_one` anywhere!\nThis is because we still have to *register the routine*, aka expose these functions to the R side.\nThis is related to that `@useDynLib` roxygen2 tag we added at the beginning.\nThat tells R to *look* for the C functions, but we still have to actually expose them too.\nLet's do that.\n\nCreate a new file, `init.c`.\nThis is the standard name for the file where this \"routine registration\" happens:\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_c(\"init\")\n```\n:::\n\nAdd the following to what is already there:\n\n::: {.cell}\n\n```{.c .cell-code}\n#define R_NO_REMAP\n#include <R.h>\n#include <Rinternals.h>\n#include <stdlib.h> // for NULL\n#include <R_ext/Rdynload.h>\n\n/* .Call calls */\nextern SEXP addr_add_one(SEXP);\n\nstatic const R_CallMethodDef CallEntries[] = {\n  {\"addr_add_one\", (DL_FUNC) &addr_add_one, 1},\n  {NULL, NULL, 0}\n};\n\nvoid R_init_addr(DllInfo *dll) {\n  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n  R_useDynamicSymbols(dll, FALSE);\n}\n```\n:::\n\nThis is the how C level functions are registered as something that can be called from the R side.\nUgly, right?\nI won't go into much detail here (I don't know everything about it myself anyways), and you'll generally only ever change 3 things.\nFirst, take a look at the section starting with \".Call calls\".\n\n::: {.cell}\n\n```{.c .cell-code}\n/* .Call calls */\nextern SEXP addr_add_one(SEXP);\n```\n:::\n\nHere, we have to list all of our C level functions that we want to expose to the R side, along with their full function signature (the argument types and return type), and we have to prefix it with `extern`.\nOur function takes 1 SEXP, `a`, as an argument, so we only have 1 SEXP specified here.\nIf your function has 2 arguments, you would do `extern SEXP my_fun(SEXP, SEXP)`.\nGenerally the only things you will pass back and forth between R and C will be SEXP objects.\nIf you have another function to export, you just add another `extern` call below this one.\n\nNext, we have to construct an \"array of call method definitions\", named `CallEntries`.\n\n::: {.cell}\n\n```{.c .cell-code}\nstatic const R_CallMethodDef CallEntries[] = {\n  {\"addr_add_one\", (DL_FUNC) &addr_add_one, 1},\n  {NULL, NULL, 0}\n};\n```\n:::\n\nIn this, you'll specify the address of the function you specified above (that's what `&addr_add_one` does), and from what I understand you convert it into a dynamically loadable function.\nBasically, you'll add one line per function you are exporting, and it is of the form:\n\n::: {.cell}\n\n```{.c .cell-code}\n{\"<function-name>\", (DL_FUNC) &<function-name>, num_args}\n```\n:::\n\nIf you have a second function to export, add another line after the first one, but before the `{NULL, NULL, 0}`.\n\nLastly, there is a function that R will automatically call for you that actually does the registration of these functions.\nR looks for a C function called `R_init_<pkg>()` to call to register these routines.\nSo the only thing you'd ever change here is to change `<pkg>` to your current package name.\n\n::: {.cell}\n\n```{.c .cell-code}\nvoid R_init_addr(DllInfo *dll) {\n  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n  R_useDynamicSymbols(dll, FALSE);\n}\n```\n:::\n\nNote how we pass the `CallEntries` into `R_registerRoutines()`.\nThis seems to be passing along all of the information required about how to create the entry points into the C code that we will call from the R side.\n\n### .Call() it!\n\nTry running `devtools::load_all()` one more time.\nYou should now have access to `addr::addr_add_one`.\nIt's not a function, so don't try and call it with `addr_add_one()`.\nLet's print it out.\n\n::: {.cell}\n\n```{.r .cell-code}\naddr::addr_add_one\n#> $name\n#> [1] \"addr_add_one\"\n#> \n#> $address\n#> <pointer: 0x7fea6b4da160>\n#> attr(,\"class\")\n#> [1] \"RegisteredNativeSymbol\"\n#> \n#> $dll\n#> DLL name: addr\n#> Filename: /Users/davis/Desktop/r/projects/data-insights-package/addr/src/addr.so\n#> Dynamic lookup: FALSE\n#> \n#> $numParameters\n#> [1] 1\n#> \n#> attr(,\"class\")\n#> [1] \"CallRoutine\"      \"NativeSymbolInfo\"\n```\n:::\n\nSo this is really just a list of class `\"CallRoutine\"` holding information about where to find the actual C function we need.\n\nSince you can't call this like a function, how do you use it?\nThe magic is with the function `.Call()`, which serves as the function that let's us call this `addr_add_one` entry point along with any arguments that we might need to pass through.\nTry the following:\n\n::: {.cell}\n\n```{.r .cell-code}\n.Call(addr_add_one, 2)\n#> [1] 3\n```\n:::\n\nWoah!\nSo that just called our C function to add 1 to 2, so we get 3.\n\n### Now what?\n\nWell, we need a better way to expose this to our users.\nThe best way is to create a function that wraps this that we can export and document.\nAlso, *we did no error checking* at the C level, so if we pass any bad or unexpected inputs in to this `.Call()`, it could actually crash R completely.\nNot just error, *crash*.\nThis isn't the worst thing in the world, and it's a pretty normal part of the development process of connecting R and C (I do it *all* the time), but it isn't fun for the user.\nTo fix that, we will also add some error checking to our function.\n\nCreate a file named `add.R`.\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_r(\"add\")\n```\n:::\n\nNow add the following:\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Add 1 to a single numeric\n#'\n#' `add_one()` adds 1 to a single numeric value.\n#'\n#' @param a A single numeric value.\n#'\n#' @examples\n#'\n#' add_one(2)\n#'\n#' @export\nadd_one <- function(a) {\n\n  ok <- is.numeric(a) & length(a) == 1L\n\n  if (!ok) {\n    stop(\"`a` must be a single numeric value.\", call. = FALSE)\n  }\n\n  .Call(addr_add_one, a)\n}\n```\n:::\n\nAt this point, call `load_all()` again and you should have access to `add_one()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(2)\n#> [1] 3\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(c(1, 2))\n#> Error: `a` must be a single numeric value.\n```\n:::\n\nAwesome!\nSince we have added the `@export` tag, to actually export this function we just need to call:\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::document()\n```\n:::\n\nwhich will create a `.Rd` help page for the file, and will add `export(add_one)` to the `NAMESPACE` file.\n\n### CRAN Check!\n\nThe only thing left is to see if it passes a cran check!\nPlot twist, it won't quite yet.\nWe need to add a license first.\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_mit_license(name = \"Davis Vaughan\")\n```\n:::\n\nOkay, now try it:\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::check()\n\n#> 0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n```\n:::\n\n😎\n\n### Resources\n\nIf you want to learn more about R's C interface, there are a few resources out there for you!\n\n-   Hadley's [R Internals documentation](https://github.com/hadley/r-internals)\n\n-   Advanced R's old [section on C](http://adv-r.had.co.nz/C-interface.html)\n\n-   The massive but thorough [Writing R Extensions](https://cran.r-project.org/doc/manuals/r-release/R-exts.html).\n    I would focus on section 5.9 on [Handling R objects in C](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Handling-R-objects-in-C).\n\n-   The full `addr` package is [on GitHub](https://github.com/DavisVaughan/addr).\n    The commit history attempts to follow this post.\n\n### Automatic Registration\n\nAs mentioned in the *Registration* section, you don't actually have to create the `init.c` file \"by hand,\" which is great because it's the thing I forget to do most.\nI've left this section until the end, rather than replacing the current *Registration* section, because I think the order of how you link things up makes more sense when done the manual way (expose to R with the `init.c` file, then `.Call()` it).\nSo if you saw that note in *Registration* and instantly skipped to here, I'd advice going back and reading the rest of that section and the rest of the blog post first.\nAs you get more familiar with working in C, you can use the methods described here.\n\nTo work with automatic registration, follow the blog post like usual, but skip the *Registration* and *.Call it!* sections and go straight to the *Now What?* section.\nGenerate the `add.R` file that looks like this:\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Add 1 to a single numeric\n#'\n#' `add_one()` adds 1 to a single numeric value.\n#'\n#' @param a A single numeric value.\n#'\n#' @examples\n#'\n#' add_one(2)\n#'\n#' @export\nadd_one <- function(a) {\n\n  ok <- is.numeric(a) & length(a) == 1L\n\n  if (!ok) {\n    stop(\"`a` must be a single numeric value.\", call. = FALSE)\n  }\n\n  .Call(addr_add_one, a)\n}\n```\n:::\n\nAt this point you should have an `add.R` file, *but no `init.c` file*.\nTry running:\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::load_all()\n```\n:::\n\nYou should have access to `add_one()`, but if you call it, you get...\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(1)\n#> Error in add_one(1) : object 'addr_add_one' not found\n```\n:::\n\nThis makes sense, because we have no `init.c` file, so the C function was not exposed to the R side.\n\nAt this point, we can generate the `init.c` file automatically using `pkgbuild::compile_dll()`.\nThe key is to run it with `register_routines = TRUE`, which will take care of automatically setting up `init.c`.\nYou may also have to run it with `force = TRUE`.\nIf you have previously compiled all of the C code already and nothing has changed, it won't try and do it again (this is generally a good thing!), and the function will exit early.\nBut we want to trigger the recompilation to make it generate the `init.c` file for us, so we should force it.\n\n::: {.cell}\n\n```{.r .cell-code}\npkgbuild::compile_dll(force = TRUE, register_routines = TRUE)\n#> Re-compiling addr\n#> ─  installing *source* package ‘addr’ ...\n#>    ** libs\n#>    clang <trimmed>  -c init.c -o init.o\n#>    clang <trimmed> -o addr.so add.o init.o\n#>    installing to /private/var/<trimmed>/addr/libs\n#> ─  DONE (addr)\n```\n:::\n\nThis output looks similar to what was generated with `devtools::load_all()`, and that's because this function is called from it.\nBut this time, you can see that it compiled an `init.c` file as well, one that it created for us!\nLet's take a look at `init.c`:\n\n::: {.cell}\n\n```{.c .cell-code}\n#include <R.h>\n#include <Rinternals.h>\n#include <stdlib.h> // for NULL\n#include <R_ext/Rdynload.h>\n\n\n/* Section generated by pkgbuild, do not edit */\n/* .Call calls */\nextern SEXP addr_add_one(SEXP);\n\nstatic const R_CallMethodDef CallEntries[] = {\n    {\"addr_add_one\", (DL_FUNC) &addr_add_one, 1},\n    {NULL, NULL, 0}\n};\n/* End section generated by pkgbuild */\n\nvoid R_init_addr(DllInfo *dll)\n{\n    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n    R_useDynamicSymbols(dll, FALSE);\n}\n```\n:::\n\nAwesome, so this entire file was created automatically, and looks essentially the same as the one that we made manually.\nNow that we have all the pieces, call `devtools::load_all()` one more time, which will sync everything up.\nThen you should be able to do:\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(1)\n#> [1] 2\n```\n:::\n\nYou'll also want to call `devtools::document()` again as well to add `export(add_one)` to the `NAMESPACE` file if you haven't already.\n\nThe reason we have to create `add_one()` first, before calling `pkgbuild::compile_dll()`, is because of the way the information is found to generate the `init.c` file.\nIt looks into your `.R` files, and scans for any calls to `.Call()`.\nThe information there, along with the name of your package, is enough to completely generate the `init.c` file!\nInternally, `compile_dll()` calls `tools::package_native_routine_registration_skeleton()` (yes, this is a mouthful), which is what generates the skeleton for `init.c`, using the information it located.\n`compile_dll()` performs a few extra steps on top of that to clean up.\n\nIf you add another C based function to your package, just call `compile_dll(register_routines = TRUE)` again, and it will update the information in the `init.c` file.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}