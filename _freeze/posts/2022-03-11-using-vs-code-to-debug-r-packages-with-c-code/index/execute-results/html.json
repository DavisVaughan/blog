{
  "hash": "673367153af0eaf5461f0f9f51c59a39",
  "result": {
    "markdown": "---\ntitle: Using VS Code to Debug R Packages with C or C++ Code\nauthor: Davis Vaughan\ndate: '2022-03-11'\nslug: using-vs-code-to-debug-r-packages-with-cpp-code\neditor_options: \n  chunk_output_type: console\n---\n\n\nThis post is intended to serve as a reference for R package developers that use C or C++ code inside their package.\nRStudio is a fantastic IDE for R code, and has an amazing debugger built in, but sometimes you need to use a different tool for debugging C++ code.\nIn a previous post, I've talked about how to use [lldb to debug an R package with C++ code](https://blog.davisvaughan.com/posts/2019-04-05-debug-r-package-with-cpp/).\nWhile this works, it lacks the elegance and ease of use that we typically expect from a full fledged debugger, i.e. setting breakpoints by clicking on the line we care about, clicking to step over or into functions, easily watching local variables change, etc.\nUnsurprisingly, the C++ community has built a number of tools that *do* have support for this, one of them being VS Code with C++ extensions, but the R community hasn't latched on to any of these yet.\nIn the remainder of this post, I'll show how to set up VS Code to debug an R package containing C++ code, which should hopefully make this tool more accessible to the R community.\n\nIf you haven't yet read my post about using lldb (linked above and again [here](https://blog.davisvaughan.com/posts/2019-04-05-debug-r-package-with-cpp/)), then I'd encourage you to do that first, as it explains some of the basics and gotchas of using lldb with R.\nThis post assumes a little working knowledge of lldb.\n\nMost of this post would not be possible without the work of [Kun Ren](https://renkun.me), who has a nice post on [VS Code Extensions for R](https://renkun.me/2022/03/06/my-recommendations-of-vs-code-extensions-for-r/) and an example repo on using [VS Code with cpp11](https://github.com/renkun-ken/vscode-cpp11-demo).\nWhile this post doesn't take the exact same approach as his, it was still invaluable for getting started.\n\nI have also had many discussions with and insights from [Jenny Bryan](https://jennybryan.org) while trying to get this to work smoothly.\n\nIf you are a VS Code expert and notice anything incorrect in this post, feel free to [open an issue](https://github.com/DavisVaughan/blog/issues) to help us improve it!\n\n## My specs\n\nIt is worth noting my personal setup, as the finer details of this post will vary a bit per operating system:\n\n-   macOS Monterey 12.2.1\n-   R 4.1.1 (*Non-notarized! See the next section.*)\n\nIf you aren't using a Mac, the absolute paths set in the configuration files below will need to be updated!\n\n## Non-notarized R\n\nThe [R for macOS FAQ](https://cran.r-project.org/bin/macosx/RMacOSX-FAQ.html#I-cannot-attach-debugger-to-R) has a bullet point named \"I cannot attach a debugger to R.\" This is particularly relevant for us, as it explains that new Apple computers require that all notarized applications use a \"Hardened Runtime\", which ends up meaning that those applications can't be utilized with a debugger like lldb.\nThe R that you typically download is a notarized application, so it falls in this category.\n\nTo get around this, you can download a non-notarized and unhardened version of R for macOS from [here](https://mac.r-project.org) instead.\nYou'll probably want the build that looks something like `R-4.1-branch`.\nPay careful attention to the OS.\nIf you have an M1 Mac, then you'll probably want the version built for the `big-sur` OS.\nOtherwise you have an Intel Mac, so you'll want the version built for the `high-sierra` OS, which works on any macOS \\>=10.13.\nIt is generally easiest to install the package, i.e.\n`R-4.1-branch.pkg`, which comes with a GUI installer.\n\n## Downloading Visual Studio Code\n\nVisual Studio Code (or VS Code for short), is a powerful IDE that supports many languages, including both R and C++.\nThe first step on our journey is to download it from [this link](https://code.visualstudio.com).\nOnce you've downloaded it, go ahead and open it.\n\n## VS Code Extensions\n\nVS Code is a generic IDE that has support for many languages through *extensions*.\nWe will need a few extensions to get started:\n\n-   [C/C++ Extension Pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack): Contains the C/C++ syntax highlighting and debugging tools, along with a number of other nice tools.\n-   [R Extension](https://marketplace.visualstudio.com/items?itemName=Ikuyadeu.r): The R extension for VS Code, which includes syntax highlighting, autocomplete, package management, and working with R Terminals inside VS Code. While not strictly necessary for us, this is pretty helpful.\n-   [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb): An lldb debugger packaged specifically for use with VS Code.\n\nThe easiest way to install extensions is to use the extension menu built into VS Code.\nIt is on the left side of the screen, and looks like 4 blocks with one of the blocks pulled out.\nI've highlighted it in this image below, along with the search bar to use to search for these extensions.\n\n![](./img/extension.png)\n\nOnce you've downloaded the extensions, restart VS Code to ensure that they are fully activated.\nThey should enable themselves by default.\n\n## VS Code exploration\n\nIt is worth taking a moment to explore VS Code for a moment.\nSince you installed the R extension, you have access to an interactive R terminal.\nYou can access it by first opening the terminal window with `Terminal -> New Terminal`.\n\n![](./img/terminal-location.png)\n\nAnd then selecting an R Terminal using the drop down menu in the right corner of the terminal window.\n\n![](./img/terminal-open.png)\n\nThis opens an R terminal where you can send commands:\n\n![](./img/terminal.png)\n\nAnother easy way to access this R terminal is to click `R: (not attached)` at the bottom right hand corner of your screen.\nThis bypasses the need to create a new terminal window.\n\n![](img/terminal-not-attached.png)\n\n## Easy setup\n\nThe easiest way to actually get familiar with VS Code is to get dropped into a project that is already set up for you, so let's do that.\nOpen RStudio and run the following, substituting your preferred parent folder as `destdir`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_from_github(\"DavisVaughan/vsexample\", destdir = \"{your/parent/folder}\")\n```\n:::\n\n\nThis example R package has a function named `buggy_init()` that we are going to be trying out.\nYou give it a single integer size, and it should create a double vector of that size filled with `2`s.\nIf you try it out in RStudio, you should get something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuggy_init(5L)\n#> [1] 6.939327e-310  2.000000e+00  2.000000e+00  2.000000e+00  2.000000e+00\n```\n:::\n\n\nThat obviously doesn't look right.\nWe'll use VS Code to figure out what is going on.\n\nGo back to VS Code and click `File -> Open...` at the top.\nNavigate to the `vsexample` folder and hit `Open`.\nIt should look like this:\n\n![](./img/vsexample.png)\n\nOn the left hand side you will see the files in the package directory.\nThis is the Explorer window.\nIf you open the `src/` directory and then open `code.cpp`, you can see the C++ file that contains `buggy_init()`.\n\nIf you open the R Terminal, you can `devtools::load_all()` and run `buggy_init(5L)` right there to see that there is a problem.\nVS Code's R extension will automatically set the working directory to the project directory, which is pretty nice.\n\n![](./img/buggy-init.png)\n\nSo let's debug this thing.\nWe don't really know what is going on, so we are going to start by setting a breakpoint on the first line of `buggy_init()`, and then we are going to walk through it line by line.\nThis is just like setting a breakpoint on an R file in RStudio, click to the left of the line number you want to set a breakpoint on, and a red circle should show up.\n\nThen switch to the Run and Debug tab on the left hand side.\nAt the top of the screen, you should see a green play arrow titled `(lldb) Launch`.\nWe will discuss how this appeared in a bit, but for now just click it.\n\n![](./img/debug-and-run.png)\n\nIf all goes well, you should get something like this shown in the video below.\nHere I step through the function using the debugging menu that pops up in the top middle of the screen.\nYou can print out variables along the way using the `var` command from lldb.\n\n<iframe width=\"100%\" height=\"400\" src=\"https://www.youtube.com/embed/_u5k-Fk2bfU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\nYou'll notice that some things aren't working exactly right, in particular we see:\n\n``` default\nvsexample.so was compiled with optimization - stepping may behave oddly; variables may not be available.\n```\n\nIf you remember from my post on [using lldb with R](https://blog.davisvaughan.com/posts/2019-04-05-debug-r-package-with-cpp/), we need to compile the package with optimization turned off to ensure that all of the debugging information is available.\nLuckily, this is easy.\nRun the following in the R Terminal of VS Code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_makevars()\n```\n:::\n\n\nThis should open your user level Makevars file in VS Code.\nAt a minimum, this should look like:\n\n``` default\nCXX11FLAGS=-O0 -g\n```\n\nThis is a C++11 based project, so we need to use `CXX11FLAGS` to set the relevant flags.\n`-O0` is used to instruct our compiler to compile without optimization and `-g` is used to ensure that all debugging information is included.\nSave this file and try to run `(lldb) Launch` again.\nThis time it should work a little better.\nI obviously know exactly where the problem is here, so I'm going to narrow in on it fairly quickly.\n[Don't forget to remove the `-O0` flag, or revert it back to `-O2` after you are finished debugging! Forgetting to revert this flag can sometimes result in performance degradation for packages that you compile from source, because you are telling the compiler not to optimize the code.]{.aside}\n\n<iframe width=\"100%\" height=\"400\" src=\"https://www.youtube.com/embed/ihkLGPSkVMY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\nIf you can't tell from the video, I end up printing out the `doubles` vector at various points during the filling process.\nAfter the first iteration of the fill loop, we see that it filled in a `2` in the *second* spot of the vector rather than the first.\nAfter one more iteration of this, this was enough for me to figure out the problem.\nOur iteration bounds are off by 1!\nWe were using 1-based indices (like R), but C++ uses 0-based indices.\nSo:\n\n``` default\nfor (R_xlen_t i = 1; i <= size; ++i) {\n```\n\nshould be:\n\n``` default\nfor (R_xlen_t i = 0; i < size; ++i) {\n```\n\nIf you make that change and recompile the package, you should get:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuggy_init(5L)\n#> [1] 2 2 2 2 2\n```\n:::\n\n\nNote that cpp11 vectors have `.begin()` and `.end()` member functions, so we could have also included the `<algorithm>` header and used `std::fill()` for this, which probably would have avoided this bug from the start!\n\n``` c\n#include <cpp11.hpp>\n#include <algorithm>\n\n[[cpp11::register]]\ncpp11::writable::doubles buggy_init(cpp11::integers size) {\n  R_xlen_t c_size = static_cast<R_xlen_t>(size[0]);\n  cpp11::writable::doubles out(c_size);\n  std::fill(out.begin(), out.end(), 2);\n  return out;\n}\n```\n\nPretty cool, right?\n\n## Local variables\n\nOne other neat feature of VS Code's debugger is the variables window in the top left corner.\nIt changes dynamically as you step through the code, and is often an easier way to inspect an object quickly when compared with using `var` or `expr` in the console, take a look:\n\n<iframe width=\"100%\" height=\"400\" src=\"https://www.youtube.com/embed/6zY0qrcKTL0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\n## Launch configuration\n\nSo how does all this work?\nHow did that `(lldb) Launch` button appear?\nHow did it know to run `buggy_init()`?\nGood questions!\n\nIn the Explorer pane you should see a `.vscode` folder, and inside that folder you should see a `launch.json` file.\nOpen that up.\n\nVS Code has what are known as *launch configurations*.\nThese perform some kind of language specific debugging action and pop up as an option in that Run and Debug menu.\nHere is ours:\n\n![](./img/launch-json.png)\n\nHere are my best guess descriptions of each of these fields:\n\n-   `name`: The name of the launch target.\n    This shows up beside the green play button in Run and Debug.\n\n-   `type`: The type of launch target to use.\n    To use our CodeLLDB extension, we have to set this to `lldb`.\n\n-   `request`: Whether this is a `launch` or `attach` type of configuration.\n    We want VS Code to *launch* a new R session for us, but we can also have it *attach* to an existing one using its process ID (PID).\n    We will keep this as launch for now, but at the end of this post I'll also show an attach example.\n\n-   `program`: The path to the program to debug.\n    This is OS specific, but most Mac users should have R in this location.\n    In any case, the executable can generally be found below the folder revealed by `R.home()`.\n\n-   `args`: Arguments to supply to the `program`.\n    Here we supply `--vanilla` to use a vanilla R session which doesn't load in any history or saved workspaces and also does not load the usual start-up files.\n    We then tell it to execute the command `source('tools/debug.R')` when it starts up the R session.\n\n-   `env`: A list of `\"name\" : \"value\"` pairs for environment variables to set before starting up the `program`.\n    The only one we seem to *need* is `R_HOME`, which you can get by calling `R.home()` in a typical R session.\n    This should be right for most Mac users already.\n\n-   `terminal`: Whether to use the Debug Console (`\"console\"`), the Integrated Terminal (`\"integrated\"`) or an External Terminal (i.e. the Terminal application) (`\"external\"`) for standard output from the `program`.\n    This is user preference, but I find that using the `\"console\"` is the most useful with a launched R session because it means that the result of the lldb command `expr Rf_PrintValue(x)` shows up right in the Debug Console rather than in a separate terminal.\n\n-   `stopOnEntry`: Should the debugger immediately stop upon activation?\n    This doesn't stop at your first breakpoint, rather, this stops right when R opens up.\n    It typically will show you some assembly code when it stops, which isn't very useful.\n\n## debug.R\n\nSo the `launch.json` file controls what happens when the Run and Debug button is pressed, but what is in the `tools/debug.R` file that is being executed?\nNavigate to that now in the Explorer pane.\nIt should have this in it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::clean_dll()\ndevtools::load_all()\n\nbuggy_init(5L)\n```\n:::\n\n\nThe idea is that we set a breakpoint on a particular line, then Launch a new R session that compiles the code, loads it (at which point the breakpoints are locked in), and then tries to call some code that we know will pass through the C++ line where we put the breakpoint.\nOnce the breakpoint is hit, we are free to step through the code and look around.\n\nFor your own projects, you'll change `buggy_init(5L)` to whatever code triggers your breakpoint or crashes your session.\n\n## C++ Properties\n\nThe other file worth looking at is `c_cpp_properties.json` in the `.vscode` folder.\nThis controls the C/C++ Extension that you installed.\nIn particular, it handles IntelliSense, the autocompletion and syntax error generator for C++.\n\nOpen that up now:\n\n![](./img/properties.png)\n\nAn easier way to edit lines in this file is `CMD+SHIFT+P` to bring up the VS Code command palette, and search for (with the leading `>`!):\n\n``` default\n>C/C++: Edit Configurations (UI)\n```\n\n![](./img/properties-menu.png)\n\nThis brings up a user friendly way to edit this JSON file, with more descriptions about each field.\nHere is my short summary:\n\n-   `name`: Typically `Mac`, `Linux` or `Win32`, this selects which configuration file to use.\n    These 3 names are special in that the corresponding configuration will be auto-selected based on the OS you are on.\n\n-   `includePath`: Folders to include for the autocompletion and syntax error generation engine.\n    This won't affect the actual code compilation process, as that is handled by R itself and your `DESCRIPTION` and `src/Makevars` files, but getting this right will improve your VS Code experience as you are tweaking your C++ files there.\n    Two important things to note here are the inclusion of R's headers, which live in `\"/Library/Frameworks/R.framework/Resources/include\"`, and the headers specific to cpp11, which live in `\"/Library/Frameworks/R.framework/Versions/Current/Resources/library/cpp11/include\"`.\n    You should always include the R headers, but if your project uses Rcpp rather than cpp11, you could alter that line to be `.../Rcpp/include` instead.\n    Basically, anything in your `LinkingTo:` field of your DESCRIPTION file should be included here.\n    Use `system.file()` to reveal where these headers are installed on your computer, e.g. `system.file(\"include\", package = \"cpp11\")`.\n\n-   `macFrameworkPath`: The path to the Mac framework folder which contains the system header files.\n    This one doesn't seem to be strictly necessary for this package, but may be useful for others.\n\n-   `compilerPath`: The compiler that would in theory be used to build the project.\n    It also enables more accurate IntelliSense because from this the C++ standard library paths are inferred.\n    This allows us to use things like `#include <algorithm>` and then autocomplete on everything in that header.\n    It is probably fine to leave this as clang, but you can change it to gcc as well.\n    The easiest way to do this is in the configuration UI mentioned earlier, under the Compiler path section.\n\n-   `cStandard`: Relevant if you are debugging C rather than C++ code (which does work!).\n    R packages are typically compiled against C99, so this is probably a good default.\n    Again, it controls how IntelliSense works.\n\n-   `cppStandard`: The C++ standard version to use for IntelliSense.\n    cpp11 projects use C++11 by default, so that is what we have chosen here.\n    It is typically a good default unless you know you need a different version.\n\n-   `version`: A version number managed by the configuration file.\n    Don't change this.\n\nLet's see what happens if we remove the cpp11 `includePath`, and then open up `code.cpp`:\n\n![](./img/include-path.png)\n\nThis just means that you are missing something in `includePath` that you are trying to use in your C++ source files.\nNote that it *won't* prevent you from running Run and Debug, and the script in `debug.R` will still compile fine.\nThis just means that for the purposes of autocompletion and syntax errors, VS Code can't find that `cpp11.hpp` file.\n\n## .Rbuildignore\n\nIt is worth quickly noting that the `.vscode` and `tools` directories should generally be committed to GitHub, but shouldn't be included in the R package when it is sent to CRAN.\nYou can avoid this by adding them to your `.Rbuildignore`.\nTo do this manually, you can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_build_ignore(c(\".vscode\", \"tools\"))\n```\n:::\n\n\nThere is also a helper function in the Setup function section at the bottom of this post that will do this for you, among other useful things.\n\n## Debugging a real rlang issue\n\nI actually used VS Code to recently debug an [rlang issue](https://github.com/r-lib/rlang/issues/1376).\nWe've already fixed the problem, but I'm going to walk through the issue in the following video to show how I tracked it down.\nIt doesn't use the typical lldb inspection tools, but instead uses the fact that I can step one line at a time to figure out where the exact issue is occurring from.\nNote that this video does have audio, unlike the others.\n\n<iframe width=\"100%\" height=\"400\" src=\"https://www.youtube.com/embed/HqwSyy4bCDU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\n## Attach configuration example\n\nYou can also *attach* the VS Code debugger to an existing R session.\nNote that if you want to set breakpoints and have them work reliably after attaching, you should attach to the R session *before* running `devtools::load_all()`.\nYou'll also need get the PID for the R session.\nThe easiest way to do this is with either `Sys.getpid()` or `ps::ps_pid()`.\n\nYou'll also need an *attach* configuration set in `launch.json`.\nYou can append to your existing configuration and set something up that looks like this:\n\n``` default\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"(lldb) Launch\",\n      \"type\": \"lldb\",\n      \"request\": \"launch\",\n      \"program\": \"/Library/Frameworks/R.framework/Resources/bin/exec/R\",\n      \"args\": [\n        \"--vanilla\",\n        \"-e\",\n        \"source('tools/debug.R')\"\n      ],\n      \"env\": {\n        \"R_HOME\" : \"/Library/Frameworks/R.framework/Resources\"\n      },\n      \"terminal\": \"console\",\n      \"stopOnEntry\": false\n    },\n    {\n      \"name\": \"(lldb) Attach\",\n      \"type\": \"lldb\",\n      \"request\": \"attach\",\n      \"pid\": \"${command:pickMyProcess}\",\n      \"stopOnEntry\": false\n    }\n  ]\n}\n```\n\nHere is an example video of attaching in action:\n\n<iframe width=\"100%\" height=\"400\" src=\"https://www.youtube.com/embed/43QxsQRluBQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\nOne nice thing about attaching is that after exiting the debugger the R session is still alive, so you can run the same function again to jump back into the debugger.\n\n## Tips\n\nBelow are a few other tips and gotchas we have learned while working with VS Code.\n\n### C++ Template Classes\n\nC++ template classes are a bit tricky to debug.\nThe cpp11 `doubles` vector is an example of this, it is a template class on `cpp11::r_vector<double>`.\nThis class has a member function called `.at()` which will return the element *at* a specific location.\n\nNow, if you try and call `expr out.at(0)` while debugging our `code.cpp` example, which doesn't use `.at()` at all, you will probably run into issues like this:\n\n``` default\nexpr out.at(0)\nerror: expression failed to parse:\nerror: Couldn't lookup symbols:\n  __ZNK5cpp118writable8r_vectorIdE2atEi\n```\n\nBecause we didn't use `.at()` anywhere in the code, the compiler *never generated code for it*.\nThis isn't being \"optimized out\" at all, it was just never generated at all to begin with.\nWe haven't found a great solution to this issue yet, but generally you can always access the internal SEXP of a cpp11 vector with `x.data_`, and then you can call any C level R function on that, like `REAL_ELT(x.data_, 0)`, in place of the `.at()` call.\n\nWe have had partial success by explicitly instantiating the template class ahead of time, although this has not proven to be universally successful yet (in particular, it has failed to compile when used with the `writable` vectors in cpp11).\nThis involves placing a line like this after `#include <cpp11.hpp>`, but before any code that tries to use a `doubles` vector.\n\n``` default\ntemplate class cpp11::r_vector<double>;\n```\n\nThis forces the compiler to fully instantiate all of `doubles`, including all of its member functions, meaning they are available to you at debug time.\nIf you do this, it is probably a good idea to remove this line after you have finished debugging.\n\n### Settings\n\nIf you hit `Command + ,` (i.e. command and comma), then you will be taken to a general settings menu for VS Code.\nYou should see a tab for User (global settings) and Workspace (settings for this workspace in particular).\n\nThere are a number of Commonly Used settings, one in particular is Tab Size, which defaults to 4, but is 2 in RStudio.\nYou may want to update this.\n\n## Setup function\n\nSince you have to set up each R package with:\n\n-   A `.vscode` folder with `launch.json` and `c_cpp_properties.json`\n-   A `tools` folder with `debug.R`\n-   An `.Rbuildignore` that ignores these\n\nIt seemed useful to wrap this up in a function.\nYou can call this function from RStudio after opening up the `Rproj` file of the R package that you want to debug.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_vscode_debug <- function() {\n  launch <- c(\n    '{',\n    '  \"version\": \"0.2.0\",',\n    '  \"configurations\": [',\n    '    {',\n    '      \"name\": \"(lldb) Launch\",',\n    '      \"type\": \"lldb\",',\n    '      \"request\": \"launch\",',\n    '      \"program\": \"/Library/Frameworks/R.framework/Resources/bin/exec/R\",',\n    '      \"args\": [',\n    '        \"--vanilla\",',\n    '        \"-e\",',\n    '        \"source(\\'tools/debug.R\\')\"',\n    '      ],',\n    '      \"env\": {',\n    '        \"R_HOME\" : \"/Library/Frameworks/R.framework/Resources\"',\n    '      },',\n    '      \"terminal\": \"console\",',\n    '      \"stopOnEntry\": false',\n    '    },',\n    '    {',\n    '      \"name\": \"(lldb) Attach\",',\n    '      \"type\": \"lldb\",',\n    '      \"request\": \"attach\",',\n    '      \"pid\": \"${command:pickMyProcess}\",',\n    '      \"stopOnEntry\": false',\n    '    }',\n    '  ]',\n    '}'\n  )\n  \n  properties <- c(\n    '{',\n    '  \"configurations\": [',\n    '    {',\n    '      \"name\": \"Mac\",',\n    '      \"includePath\": [',\n    '        \"${workspaceFolder}/**\",',\n    '        \"/Library/Frameworks/R.framework/Resources/include\",',\n    '        \"/Library/Frameworks/R.framework/Versions/Current/Resources/library/cpp11/include\"',\n    '      ],',\n    '      \"defines\": [],',\n    '      \"macFrameworkPath\": [',\n    '        \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks\"',\n    '      ],',\n    '      \"compilerPath\": \"/usr/bin/clang\",',\n    '      \"cStandard\": \"c99\",',\n    '      \"cppStandard\": \"c++11\"',\n    '    }',\n    '  ],',\n    '  \"version\": 4',\n    '}'\n  )\n  \n  debug <- c(\n    'devtools::clean_dll()',\n    'devtools::load_all()',\n    '',\n    '1 + 1'\n  )\n  \n  usethis::use_directory(\".vscode\", ignore = TRUE)\n  usethis::write_over(\".vscode/launch.json\", lines = launch)\n  usethis::write_over(\".vscode/c_cpp_properties.json\", lines = properties)\n  \n  usethis::use_directory(\"tools\", ignore = TRUE)\n  usethis::write_over(\"tools/debug.R\", lines = debug)\n}\n```\n:::\n\n\n## References\n\n-   [My recommendations of VS Code extensions for R](https://renkun.me/2022/03/06/my-recommendations-of-vs-code-extensions-for-r/)\n-   [VS Code cpp11 Demo](https://github.com/renkun-ken/vscode-cpp11-demo). This doesn't use CodeLLDB, but instead uses the built in lldb that comes with Mac. I found that the CodeLLDB experience was much smoother.\n-   [CodeLLDB Manual](https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md), with documentation for all of the configuration arguments.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}